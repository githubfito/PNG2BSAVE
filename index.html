<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Conversor PNG ‚Üî BSAVE (CGA)</title>
    <style>
        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: #1a1a1a;
            color: #0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        h1 { text-shadow: 2px 2px #000; margin-bottom: 10px; }
        
        .main-container {
            background: #333;
            padding: 20px;
            border: 2px solid #555;
            border-radius: 8px;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* 1. Selecci√≥n de Modo */
        .mode-selection {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 10px;
            border-bottom: 1px dashed #777;
            padding-bottom: 15px;
        }

        .mode-selection input[type="radio"] { display: none; }
        .mode-selection label {
            padding: 8px 15px;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }
        .mode-selection input[type="radio"]:checked + label {
            background-color: #aa00aa;
            border-color: #ff55ff;
            color: #fff;
        }
        .mode-selection label:hover:not(.mode-selection input[type="radio"]:checked + label) {
            background-color: #444;
        }
        
        /* 2. Controles de Archivo (Ahora arriba) */
        .controls {
            padding-bottom: 10px;
        }

        button {
            background-color: #aa00aa; 
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 18px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            margin-top: 10px;
        }
        button:hover { background-color: #ff55ff; }
        button:disabled { background-color: #555; cursor: not-allowed; }

        /* 3. Lienzos */
        .canvas-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            padding-top: 10px; 
            border-top: 1px dashed #777;
        }
        
        .canvas-label {
            background: #000;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.9em;
            color: #fff;
        }

        canvas {
            border: 4px solid #fff;
            image-rendering: pixelated;
            width: 640px; 
            height: 400px;
            background: #000;
        }

        .code-block {
            background: #000;
            border: 1px solid #444;
            padding: 15px;
            text-align: left;
            margin-top: 20px;
            width: 100%;
            max-width: 600px;
            font-size: 0.85em;
        }
    </style>
</head>
<body>

    <h1>PNG ‚Üî BSAVE (CGA SCREEN 1)</h1>

    <div class="main-container">

        <div class="mode-selection">
            <input type="radio" id="modePngToBsave" name="conversionMode" value="pngToBsave" checked>
            <label for="modePngToBsave">1) üñºÔ∏è PNG a .BSV</label>

            <input type="radio" id="modeBsaveToPng" name="conversionMode" value="bsaveToPng">
            <label for="modeBsaveToPng">2) üíæ .BSV a PNG</label>
        </div>
        
        <div class="controls">
            <input type="file" id="fileInput" accept="image/*, .bsv">
            <br>
            <p id="status" style="color:#aaa">Selecciona una imagen...</p>
            <button id="btnConvert" disabled>üíæ Descargar .BSV</button>
        </div>


        <div id="canvasPngToBsave" class="canvas-wrapper">
            <span class="canvas-label" id="originalCanvasLabel">Original (Redimensionado 320x200)</span>
            <canvas id="canvasOriginal" width="320" height="200"></canvas>
        </div>

        <div class="canvas-wrapper">
            <span class="canvas-label" id="cgaCanvasLabel">CGA 4 Colores (Dithering Floyd-Steinberg)</span>
            <canvas id="canvasCGA" width="320" height="200"></canvas>
        </div>

    </div>

    <div class="code-block">
        <strong>C√≥digo PowerBASIC 3.5 para carga:</strong>
<pre style="color: #ccc; margin:0;">
SCREEN 1
COLOR 0, 1  ' Fondo negro, Paleta 1 (Cian, Magenta, Blanco)
DEF SEG = &HB800
BLOAD "IMAGEN.BSV", 0
DEF SEG
WAITKEY$
SCREEN 0
</pre>
    </div>

    <script>
        // === PALETA CGA (Paleta 1: Fondo negro, colores cian, magenta, blanco) ===
        const PALETTE = [
            { r: 0,   g: 0,   b: 0, index: 0 },    // 0: Negro
            { r: 85,  g: 255, b: 255, index: 1 }, // 1: Cian (Alto Brillo)
            { r: 255, g: 85,  b: 255, index: 2 }, // 2: Magenta (Alto Brillo)
            { r: 255, g: 255, b: 255, index: 3 }  // 3: Blanco (Alto Brillo)
        ];
        const CGA_WIDTH = 320;
        const CGA_HEIGHT = 200;
        const CGA_MEMORY_SIZE = 16384; 

        const fileInput = document.getElementById('fileInput');
        const btnConvert = document.getElementById('btnConvert');
        const status = document.getElementById('status');
        const modeRadios = document.querySelectorAll('input[name="conversionMode"]');
        const canvasOriginal = document.getElementById('canvasOriginal');
        const canvasCGA = document.getElementById('canvasCGA');
        const ctxOrig = canvasOriginal.getContext('2d');
        const ctxCGA = canvasCGA.getContext('2d', { willReadFrequently: true });
        const canvasPngToBsaveDiv = document.getElementById('canvasPngToBsave');
        const originalCanvasLabel = document.getElementById('originalCanvasLabel');
        const cgaCanvasLabel = document.getElementById('cgaCanvasLabel');
        
        let currentMode = 'pngToBsave';
        let fileName = "imagen";

        // === UTILIDADES ===

        function getClosestColorIndex(r, g, b) {
            let minDiff = Infinity;
            let closest = 0;
            PALETTE.forEach((col, index) => {
                const diff = (r - col.r)**2 + (g - col.g)**2 + (b - col.b)**2;
                if (diff < minDiff) { minDiff = diff; closest = index; }
            });
            return closest;
        }

        function clamp(value) {
            return Math.max(0, Math.min(255, value));
        }

        // === CAMBIO DE MODO ===
        function updateMode(mode) {
            currentMode = mode;
            fileInput.value = ''; 
            btnConvert.disabled = true;
            ctxOrig.clearRect(0, 0, CGA_WIDTH, CGA_HEIGHT);
            ctxCGA.clearRect(0, 0, CGA_WIDTH, CGA_HEIGHT);
            
            if (mode === 'pngToBsave') {
                fileInput.accept = 'image/*';
                canvasPngToBsaveDiv.style.display = 'flex'; // Mostrar ambos
                originalCanvasLabel.innerText = 'Original (Redimensionado 320x200)';
                cgaCanvasLabel.innerText = 'CGA 4 Colores (Dithering Floyd-Steinberg)';
                btnConvert.innerText = 'üíæ Descargar .BSV';
                status.innerText = 'Selecciona una imagen PNG o JPG...';
            } else {
                fileInput.accept = '.bsv';
                canvasPngToBsaveDiv.style.display = 'flex'; // Mantener visible el superior
                originalCanvasLabel.innerText = 'Previsualizaci√≥n 1';
                cgaCanvasLabel.innerText = 'Previsualizaci√≥n 2';
                btnConvert.innerText = 'üñºÔ∏è Descargar PNG';
                status.innerText = 'Selecciona un archivo .BSV (Formato CGA SCREEN 1)...';
            }
        }
        modeRadios.forEach(radio => radio.addEventListener('change', (e) => updateMode(e.target.value)));
        updateMode(currentMode); 


        // === 1. L√ìGICA PNG a BSAVE (Conversi√≥n + Dithering) ===

        function applyFloydSteinberg(data) {
            const width = CGA_WIDTH;
            const height = CGA_HEIGHT;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;

                    const oldR = data[i];
                    const oldG = data[i + 1];
                    const oldB = data[i + 2];

                    const closestIdx = getClosestColorIndex(oldR, oldG, oldB);
                    const newColor = PALETTE[closestIdx];

                    data[i] = newColor.r;
                    data[i + 1] = newColor.g;
                    data[i + 2] = newColor.b;

                    const errR = oldR - newColor.r;
                    const errG = oldG - newColor.g;
                    const errB = oldB - newColor.b;

                    distributeError(data, x + 1, y, errR, errG, errB, 7 / 16);
                    distributeError(data, x - 1, y + 1, errR, errG, errB, 3 / 16);
                    distributeError(data, x, y + 1, errR, errG, errB, 5 / 16);
                    distributeError(data, x + 1, y + 1, errR, errG, errB, 1 / 16);
                }
            }
        }

        function distributeError(data, x, y, errR, errG, errB, factor) {
            if (x < 0 || x >= CGA_WIDTH || y >= CGA_HEIGHT) return;
            const i = (y * CGA_WIDTH + x) * 4;
            
            data[i] = clamp(data[i] + errR * factor);
            data[i+1] = clamp(data[i+1] + errG * factor);
            data[i+2] = clamp(data[i+2] + errB * factor);
        }

        function generateBsave(pixels) {
            const buffer = new Uint8Array(7 + CGA_MEMORY_SIZE);
            const view = new DataView(buffer.buffer);

            // Header BSAVE
            view.setUint8(0, 0xFD);
            view.setUint16(1, 0x0000, true); 
            view.setUint16(3, 0xB800, true); 
            view.setUint16(5, CGA_MEMORY_SIZE, true); 

            // L√≥gica de entrelazado CGA
            const EVEN_OFFSET = 7;
            const ODD_OFFSET = 7 + CGA_MEMORY_SIZE / 2; 

            for (let y = 0; y < CGA_HEIGHT; y++) {
                const isOdd = (y % 2 !== 0);
                const lineIndex = Math.floor(y / 2); 
                const baseOffset = isOdd ? ODD_OFFSET : EVEN_OFFSET;
                const lineStart = baseOffset + (lineIndex * 80); 

                for (let x = 0; x < CGA_WIDTH; x += 4) {
                    let byteVal = 0;
                    for (let k = 0; k < 4; k++) {
                        const pixelX = x + k;
                        const idx = ((y * CGA_WIDTH) + pixelX) * 4;
                        
                        let colorIndex = 0; 
                        
                        const r = pixels[idx];
                        const g = pixels[idx+1];
                        const b = pixels[idx+2];
                        
                        for(let c=0; c<PALETTE.length; c++) {
                            const pal = PALETTE[c];
                            if (r === pal.r && g === pal.g && b === pal.b) {
                                colorIndex = pal.index;
                                break;
                            }
                        }
                        
                        byteVal |= (colorIndex << (6 - (k * 2)));
                    }
                    buffer[lineStart + (x / 4)] = byteVal;
                }
            }
            return buffer;
        }

        // === 2. L√ìGICA BSAVE a PNG (Descompresi√≥n) ===
        
        function processBsave(buffer) {
            const data = new DataView(buffer);

            if (data.getUint8(0) !== 0xFD) {
                status.innerText = "Error: Archivo no parece ser un formato BSAVE v√°lido (Cabecera 0xFD).";
                btnConvert.disabled = true;
                return;
            }

            const imgData = ctxCGA.createImageData(CGA_WIDTH, CGA_HEIGHT);
            const pixels = imgData.data;

            const EVEN_OFFSET = 7;
            const ODD_OFFSET = 7 + CGA_MEMORY_SIZE / 2;

            for (let y = 0; y < CGA_HEIGHT; y++) {
                const isOdd = (y % 2 !== 0);
                const lineIndex = Math.floor(y / 2);
                const baseOffset = isOdd ? ODD_OFFSET : EVEN_OFFSET;
                const lineStart = baseOffset + (lineIndex * 80);

                for (let x = 0; x < CGA_WIDTH; x += 4) {
                    const byteIndex = lineStart + (x / 4);
                    const byteVal = data.getUint8(byteIndex);

                    for (let k = 0; k < 4; k++) {
                        const colorIndex = (byteVal >> (6 - (k * 2))) & 0x03;
                        const color = PALETTE[colorIndex];

                        const pixelIndex = ((y * CGA_WIDTH) + (x + k)) * 4;
                        
                        pixels[pixelIndex] = color.r;
                        pixels[pixelIndex + 1] = color.g;
                        pixels[pixelIndex + 2] = color.b;
                        pixels[pixelIndex + 3] = 255; 
                    }
                }
            }
            
            // 1. Dibujar en el lienzo CGA (inferior)
            ctxCGA.putImageData(imgData, 0, 0);
            
            // 2. Copiar al lienzo superior (Original) para tener doble previsualizaci√≥n
            ctxOrig.putImageData(imgData, 0, 0);

            btnConvert.disabled = false;
            status.innerText = `‚úÖ Conversi√≥n lista. Descarga el PNG de ${CGA_WIDTH}x${CGA_HEIGHT}.`;
        }


        // === CONTROLADOR PRINCIPAL DE ARCHIVOS ===
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            fileName = file.name.split('.')[0];
            ctxOrig.clearRect(0, 0, CGA_WIDTH, CGA_HEIGHT);
            ctxCGA.clearRect(0, 0, CGA_WIDTH, CGA_HEIGHT);
            btnConvert.disabled = true;
            status.innerText = "Procesando...";

            if (currentMode === 'pngToBsave') {
                const img = new Image();
                const url = URL.createObjectURL(file);

                img.onload = () => {
                    ctxOrig.drawImage(img, 0, 0, CGA_WIDTH, CGA_HEIGHT);
                    ctxCGA.drawImage(img, 0, 0, CGA_WIDTH, CGA_HEIGHT);
                    
                    setTimeout(() => {
                        const imgData = ctxCGA.getImageData(0, 0, CGA_WIDTH, CGA_HEIGHT);
                        applyFloydSteinberg(imgData.data);
                        ctxCGA.putImageData(imgData, 0, 0);
                        btnConvert.disabled = false;
                        status.innerText = "‚úÖ Conversi√≥n lista. Compara las im√°genes.";
                    }, 50); 
                    
                    URL.revokeObjectURL(url);
                };
                img.src = url;

            } else if (currentMode === 'bsaveToPng') {
                try {
                    const buffer = await file.arrayBuffer();
                    processBsave(buffer);
                } catch (error) {
                    status.innerText = `Error al leer el archivo BSAVE: ${error.message}`;
                    console.error(error);
                }
            }
        });


        // === CONTROLADOR DE DESCARGA ===
        btnConvert.addEventListener('click', () => {
            if (currentMode === 'pngToBsave') {
                const imgData = ctxCGA.getImageData(0, 0, CGA_WIDTH, CGA_HEIGHT);
                const buffer = generateBsave(imgData.data);
                
                const blob = new Blob([buffer], { type: "application/octet-stream" });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = fileName + "_CGA.BSV";
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } else if (currentMode === 'bsaveToPng') {
                // Descargamos el contenido del canvas CGA, que ya tiene el PNG descompuesto
                const link = document.createElement('a');
                link.download = fileName + "_CGA.png";
                link.href = canvasCGA.toDataURL('image/png');
                link.click();
            }
        });
    </script>
</body>
</html>
