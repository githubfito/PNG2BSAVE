<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Conversor PNG ‚Üî BSAVE (CGA)</title>
    <style>
        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: #1a1a1a;
            color: #0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        h1 { text-shadow: 2px 2px #000; margin-bottom: 10px; }
        
        .main-container {
            background: #333;
            padding: 20px;
            border: 2px solid #555;
            border-radius: 8px;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* 1. Selecci√≥n de Modo */
        .mode-selection {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 10px;
            border-bottom: 1px dashed #777;
            padding-bottom: 15px;
        }

        .mode-selection input[type="radio"] { display: none; }
        .mode-selection label {
            padding: 8px 15px;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }
        .mode-selection input[type="radio"]:checked + label {
            background-color: #aa00aa;
            border-color: #ff55ff;
            color: #fff;
        }
        .mode-selection label:hover:not(.mode-selection input[type="radio"]:checked + label) {
            background-color: #444;
        }
        
        /* 2. Controles de Archivo (Ahora arriba) */
        .controls {
            padding-bottom: 10px;
        }

        .settings-row {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap; 
            justify-content: center;
            align-items: center;
            gap: 15px;
            font-size: 0.9em;
        }
        
        select {
            background-color: #555;
            color: #0f0;
            border: 1px solid #777;
            padding: 5px;
            border-radius: 3px;
            font-family: inherit;
        }
        .settings-row label {
            color: #ccc;
        }


        button {
            background-color: #aa00aa; 
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 18px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            margin-top: 10px;
        }
        button:hover { background-color: #ff55ff; }
        button:disabled { background-color: #555; cursor: not-allowed; }

        /* 3. Lienzos */
        .canvas-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            padding-top: 10px; 
            border-top: 1px dashed #777;
        }
        
        .canvas-label {
            background: #000;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.9em;
            color: #fff;
        }

        canvas {
            border: 4px solid #fff;
            image-rendering: pixelated;
            width: 640px; 
            height: 400px;
            background: #000;
        }

        .code-block {
            background: #000;
            border: 1px solid #444;
            padding: 15px;
            text-align: left;
            margin-top: 20px;
            width: 100%;
            max-width: 600px;
            font-size: 0.85em;
        }
    </style>
</head>
<body>

    <h1>PNG ‚Üî BSAVE (CGA SCREEN 1)</h1>

    <div class="main-container">

        <div class="mode-selection">
            <input type="radio" id="modePngToBsave" name="conversionMode" value="pngToBsave" checked>
            <label for="modePngToBsave">1) üñºÔ∏è PNG a .BSV</label>

            <input type="radio" id="modeBsaveToPng" name="conversionMode" value="bsaveToPng">
            <label for="modeBsaveToPng">2) üíæ .BSV a PNG</label>
        </div>
        
        <div class="controls">
            <input type="file" id="fileInput" accept="image/*, .bsv">
            <div id="pngSettings" class="settings-row">
                <input type="checkbox" id="chkResize" checked>
                <label for="chkResize">Adaptar a 320x200 (Estirar)</label>
                
                <label for="selectPalette">Paleta:</label>
                <select id="selectPalette">
                    <option value="palette1">Paleta 1 (Cian, Magenta, Blanco)</option>
                    <option value="palette2">Paleta 2 (Verde, Rojo, Marr√≥n)</option>
                </select>
                
                <label for="selectDithering">Dithering:</label>
                <select id="selectDithering">
                    <option value="floyd-steinberg" selected>Floyd-Steinberg (Granulado)</option>
                    <option value="bayer">Bayer 4x4 (Patr√≥n S√≥lido)</option>
                    <option value="jjn">Jarvis-Judice-Ninke (Alta Calidad)</option>
                    <option value="stucki">Stucki (Buen Balance)</option>
                    <option value="none">Ninguno (Umbral Fijo)</option>
                </select>
            </div>
            <p id="status" style="color:#aaa">Selecciona una imagen...</p>
            <button id="btnConvert" disabled>üíæ Descargar .BSV</button>
        </div>


        <div id="canvasPngToBsave" class="canvas-wrapper">
            <span class="canvas-label" id="originalCanvasLabel">Original (Redimensionado)</span>
            <canvas id="canvasOriginal" width="320" height="200"></canvas>
        </div>

        <div class="canvas-wrapper">
            <span class="canvas-label" id="cgaCanvasLabel">CGA 4 Colores (Dithering)</span>
            <canvas id="canvasCGA" width="320" height="200"></canvas>
        </div>

    </div>

    <div class="code-block">
        <strong>C√≥digo PowerBASIC 3.5 para carga:</strong>
<pre style="color: #ccc; margin:0;">
SCREEN 1
COLOR 0, 1  ' Ejemplo para Paleta 1 (Fondo Negro, Paleta 1)
DEF SEG = &HB800
BLOAD "IMAGEN.BSV", 0
DEF SEG
WAITKEY$
SCREEN 0
</pre>
    </div>

    <script>
        // === DEFINICIONES Y CONSTANTES ===
        const CGA_PALETTES = {
            palette1: [
                { r: 0,   g: 0,   b: 0, index: 0 },
                { r: 85,  g: 255, b: 255, index: 1 }, 
                { r: 255, g: 85,  b: 255, index: 2 }, 
                { r: 255, g: 255, b: 255, index: 3 }
            ],
            palette2: [ 
                { r: 0,   g: 0,   b: 0, index: 0 },
                { r: 85,  g: 255, b: 85, index: 1 }, 
                { r: 255, g: 85,  b: 85, index: 2 },  
                { r: 255, g: 255, b: 85, index: 3 }
            ]
        };
        const CGA_WIDTH = 320;
        const CGA_HEIGHT = 200;
        const CGA_MEMORY_SIZE = 16384; 
        
        // Matriz de Bayer 4x4
        const BAYER_MATRIX = [
            [0, 8, 2, 10],
            [12, 4, 14, 6],
            [3, 11, 1, 9],
            [15, 7, 13, 5]
        ];
        const BAYER_SIZE = 4;
        const BAYER_DIVISOR = BAYER_SIZE * BAYER_SIZE; // 16

        // === ESTADO GLOBAL ===
        let currentMode = 'pngToBsave';
        let fileName = "imagen";
        let currentImage = null; 

        // === ELEMENTOS DEL DOM ===
        const fileInput = document.getElementById('fileInput');
        const btnConvert = document.getElementById('btnConvert');
        const status = document.getElementById('status');
        const modeRadios = document.querySelectorAll('input[name="conversionMode"]');
        const chkResize = document.getElementById('chkResize');
        const pngSettingsDiv = document.getElementById('pngSettings');
        const selectPalette = document.getElementById('selectPalette'); 
        const selectDithering = document.getElementById('selectDithering'); 

        const canvasOriginal = document.getElementById('canvasOriginal');
        const canvasCGA = document.getElementById('canvasCGA');
        const ctxOrig = canvasOriginal.getContext('2d');
        const ctxCGA = canvasCGA.getContext('2d', { willReadFrequently: true });
        const canvasPngToBsaveDiv = document.getElementById('canvasPngToBsave');
        const originalCanvasLabel = document.getElementById('originalCanvasLabel');
        const cgaCanvasLabel = document.getElementById('cgaCanvasLabel');
        
        let activePalette = CGA_PALETTES[selectPalette.value];


        // === UTILIDADES ===

        function getClosestColorIndex(r, g, b, palette) {
            let minDiff = Infinity;
            let closest = 0;
            palette.forEach((col, index) => {
                // Distancia euclidiana simplificada (sin ra√≠z cuadrada)
                const diff = (r - col.r)**2 + (g - col.g)**2 + (b - col.b)**2;
                if (diff < minDiff) { minDiff = diff; closest = index; }
            });
            return closest;
        }

        function clamp(value) {
            return Math.max(0, Math.min(255, value));
        }

        function calculateFitDimensions(imgW, imgH, targetW, targetH) {
            const ratioW = targetW / imgW;
            const ratioH = targetH / imgH;
            const ratio = Math.min(ratioW, ratioH); 

            const newW = imgW * ratio;
            const newH = imgH * ratio;

            const offsetX = (targetW - newW) / 2;
            const offsetY = (targetH - newH) / 2;

            return { newW: newW, newH: newH, offsetX: offsetX, offsetY: offsetY };
        }

        function updateCodeBlock(paletteKey) {
            const codeBlock = document.querySelector('.code-block pre');
            let colorSetting = '';
            
            if (paletteKey === 'palette1') {
                colorSetting = 'COLOR 0, 1  \' Fondo Negro, Paleta 1 (Cian, Magenta, Blanco)';
            } else if (paletteKey === 'palette2') {
                colorSetting = 'COLOR 0, 0  \' Fondo Negro, Paleta 0 (Verde, Rojo, Marr√≥n)';
            }

            codeBlock.innerHTML = `
SCREEN 1
${colorSetting}
DEF SEG = &HB800
BLOAD "IMAGEN.BSV", 0
DEF SEG
WAITKEY$
SCREEN 0
`.trim();
        }

        // === CAMBIO DE MODO ===
        function updateMode(mode) {
            currentMode = mode;
            fileInput.value = ''; 
            btnConvert.disabled = true;
            ctxOrig.clearRect(0, 0, CGA_WIDTH, CGA_HEIGHT);
            ctxCGA.clearRect(0, 0, CGA_WIDTH, CGA_HEIGHT);
            currentImage = null; 
            
            activePalette = CGA_PALETTES[selectPalette.value];

            if (mode === 'pngToBsave') {
                fileInput.accept = 'image/*';
                pngSettingsDiv.style.display = 'flex'; 
                selectDithering.style.display = 'block'; 
                canvasPngToBsaveDiv.style.display = 'flex'; 
                originalCanvasLabel.innerText = 'Original (Redimensionado)';
                cgaCanvasLabel.innerText = 'CGA 4 Colores (Dithering)';
                btnConvert.innerText = 'üíæ Descargar .BSV';
                status.innerText = 'Selecciona una imagen PNG o JPG...';
            } else {
                fileInput.accept = '.bsv';
                pngSettingsDiv.style.display = 'none'; 
                selectDithering.style.display = 'none'; 
                canvasPngToBsaveDiv.style.display = 'flex'; 
                originalCanvasLabel.innerText = 'Previsualizaci√≥n 1 (Desde BSAVE)';
                cgaCanvasLabel.innerText = 'Previsualizaci√≥n 2 (Desde BSAVE)';
                btnConvert.innerText = 'üñºÔ∏è Descargar PNG';
                status.innerText = 'Selecciona un archivo .BSV (Formato CGA SCREEN 1)...';
            }

            updateCodeBlock(selectPalette.value); 
        }

        // --- Dithering Algoritmos ---

        // Funci√≥n auxiliar para distribuir el error
        function distributeError(data, x, y, errR, errG, errB, factor) {
            if (x < 0 || x >= CGA_WIDTH || y >= CGA_HEIGHT) return;
            const i = (y * CGA_WIDTH + x) * 4;
            
            data[i] = clamp(data[i] + errR * factor);
            data[i+1] = clamp(data[i+1] + errG * factor);
            data[i+2] = clamp(data[i+2] + errB * factor);
        }
        
        // 1. Floyd-Steinberg (Dispersi√≥n de Error: 16)
        function applyFloydSteinberg(data, palette) {
            const width = CGA_WIDTH;
            const height = CGA_HEIGHT;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;

                    const oldR = data[i];
                    const oldG = data[i + 1];
                    const oldB = data[i + 2];

                    const closestIdx = getClosestColorIndex(oldR, oldG, oldB, palette); 
                    const newColor = palette[closestIdx];

                    data[i] = newColor.r; data[i + 1] = newColor.g; data[i + 2] = newColor.b;

                    const errR = oldR - newColor.r;
                    const errG = oldG - newColor.g;
                    const errB = oldB - newColor.b;

                    // Distribuci√≥n del error: [7/16] [3/16] [5/16] [1/16]
                    distributeError(data, x + 1, y, errR, errG, errB, 7 / 16);
                    distributeError(data, x - 1, y + 1, errR, errG, errB, 3 / 16);
                    distributeError(data, x, y + 1, errR, errG, errB, 5 / 16);
                    distributeError(data, x + 1, y + 1, errR, errG, errB, 1 / 16);
                }
            }
        }
        
        // 2. Jarvis, Judice & Ninke (Dispersi√≥n de Error: 48)
        function applyJarvisJudiceNinke(data, palette) {
            const width = CGA_WIDTH;
            const height = CGA_HEIGHT;
            const divisor = 48; // Total de la suma de pesos

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;

                    const oldR = data[i];
                    const oldG = data[i + 1];
                    const oldB = data[i + 2];

                    const closestIdx = getClosestColorIndex(oldR, oldG, oldB, palette); 
                    const newColor = palette[closestIdx];

                    data[i] = newColor.r; data[i + 1] = newColor.g; data[i + 2] = newColor.b;

                    const errR = oldR - newColor.r;
                    const errG = oldG - newColor.g;
                    const errB = oldB - newColor.b;

                    // Fila 1: (7) (5)
                    distributeError(data, x + 1, y, errR, errG, errB, 7 / divisor);
                    distributeError(data, x + 2, y, errR, errG, errB, 5 / divisor);
                    
                    // Fila 2: (3) (5) (7) (5) (3)
                    distributeError(data, x - 2, y + 1, errR, errG, errB, 3 / divisor);
                    distributeError(data, x - 1, y + 1, errR, errG, errB, 5 / divisor);
                    distributeError(data, x, y + 1, errR, errG, errB, 7 / divisor);
                    distributeError(data, x + 1, y + 1, errR, errG, errB, 5 / divisor);
                    distributeError(data, x + 2, y + 1, errR, errG, errB, 3 / divisor);
                    
                    // Fila 3: (1) (3) (5) (3) (1)
                    distributeError(data, x - 2, y + 2, errR, errG, errB, 1 / divisor);
                    distributeError(data, x - 1, y + 2, errR, errG, errB, 3 / divisor);
                    distributeError(data, x, y + 2, errR, errG, errB, 5 / divisor);
                    distributeError(data, x + 1, y + 2, errR, errG, errB, 3 / divisor);
                    distributeError(data, x + 2, y + 2, errR, errG, errB, 1 / divisor);
                }
            }
        }
        
        // 3. Stucki (Dispersi√≥n de Error: 42)
        function applyStucki(data, palette) {
            const width = CGA_WIDTH;
            const height = CGA_HEIGHT;
            const divisor = 42; // Total de la suma de pesos

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;

                    const oldR = data[i];
                    const oldG = data[i + 1];
                    const oldB = data[i + 2];

                    const closestIdx = getClosestColorIndex(oldR, oldG, oldB, palette); 
                    const newColor = palette[closestIdx];

                    data[i] = newColor.r; data[i + 1] = newColor.g; data[i + 2] = newColor.b;

                    const errR = oldR - newColor.r;
                    const errG = oldG - newColor.g;
                    const errB = oldB - newColor.b;

                    // Fila 1: (8) (4)
                    distributeError(data, x + 1, y, errR, errG, errB, 8 / divisor);
                    distributeError(data, x + 2, y, errR, errG, errB, 4 / divisor);
                    
                    // Fila 2: (2) (4) (8) (4) (2)
                    distributeError(data, x - 2, y + 1, errR, errG, errB, 2 / divisor);
                    distributeError(data, x - 1, y + 1, errR, errG, errB, 4 / divisor);
                    distributeError(data, x, y + 1, errR, errG, errB, 8 / divisor);
                    distributeError(data, x + 1, y + 1, errR, errG, errB, 4 / divisor);
                    distributeError(data, x + 2, y + 1, errR, errG, errB, 2 / divisor);
                    
                    // Fila 3: (1) (2) (4) (2) (1)
                    distributeError(data, x - 2, y + 2, errR, errG, errB, 1 / divisor);
                    distributeError(data, x - 1, y + 2, errR, errG, errB, 2 / divisor);
                    distributeError(data, x, y + 2, errR, errG, errB, 4 / divisor);
                    distributeError(data, x + 1, y + 2, errR, errG, errB, 2 / divisor);
                    distributeError(data, x + 2, y + 2, errR, errG, errB, 1 / divisor);
                }
            }
        }


        // 4. Bayer Ordered Dithering (Umbral Ordenado)
        function applyBayerDithering(data, palette) {
            const width = CGA_WIDTH;
            const height = CGA_HEIGHT;
            const thresholdScale = 255 / (palette.length - 1) / BAYER_DIVISOR;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;

                    const oldR = data[i];
                    const oldG = data[i + 1];
                    const oldB = data[i + 2];
                    
                    const bayerThreshold = BAYER_MATRIX[y % BAYER_SIZE][x % BAYER_SIZE] * thresholdScale;

                    const r = clamp(oldR + bayerThreshold);
                    const g = clamp(oldG + bayerThreshold);
                    const b = clamp(oldB + bayerThreshold);

                    const closestIdx = getClosestColorIndex(r, g, b, palette);
                    const newColor = palette[closestIdx];

                    data[i] = newColor.r; data[i + 1] = newColor.g; data[i + 2] = newColor.b;
                }
            }
        }

        // 5. Ninguno (Umbral Fijo)
        function applyNoDithering(data, palette) {
            const width = CGA_WIDTH;
            const height = CGA_HEIGHT;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const i = (y * width + x) * 4;
                    
                    const closestIdx = getClosestColorIndex(data[i], data[i+1], data[i+2], palette);
                    const newColor = palette[closestIdx];

                    data[i] = newColor.r; data[i + 1] = newColor.g; data[i + 2] = newColor.b;
                }
            }
        }


        // Funci√≥n principal de procesamiento de imagen PNG
        function processImage(img) {
            if (currentMode !== 'pngToBsave') return; 

            status.innerText = "Procesando...";
            activePalette = CGA_PALETTES[selectPalette.value];
            const ditheringMode = selectDithering.value; 

            // 1. Limpiar lienzos y dibujar fondo negro (0, 0, 0)
            ctxOrig.fillStyle = 'black';
            ctxOrig.fillRect(0, 0, CGA_WIDTH, CGA_HEIGHT);
            ctxCGA.fillStyle = 'black';
            ctxCGA.fillRect(0, 0, CGA_WIDTH, CGA_HEIGHT);

            const adaptChecked = chkResize.checked;
            let drawX, drawY, drawW, drawH;
            
            if (adaptChecked) {
                drawX = 0; drawY = 0; drawW = CGA_WIDTH; drawH = CGA_HEIGHT;
                originalCanvasLabel.innerText = 'Original (Estirado 320x200)';
            } else {
                const fit = calculateFitDimensions(img.width, img.height, CGA_WIDTH, CGA_HEIGHT);
                drawW = fit.newW; drawH = fit.newH; drawX = fit.offsetX; drawY = fit.offsetY;
                originalCanvasLabel.innerText = 'Original (Ajustado A.R.)';
            }

            // 2. Dibujar imagen redimensionada
            ctxOrig.drawImage(img, drawX, drawY, drawW, drawH);
            ctxCGA.drawImage(img, drawX, drawY, drawW, drawH);
            
            // 3. Aplicar Dithering CGA
            // Usamos setTimeout para asegurar que el DOM refresque la imagen antes de leerla
            // (aunque no es estrictamente necesario en este entorno simple, ayuda a simular un proceso)
            setTimeout(() => {
                try {
                    const imgData = ctxCGA.getImageData(0, 0, CGA_WIDTH, CGA_HEIGHT);
                    
                    let ditheringName = '';

                    if (ditheringMode === 'floyd-steinberg') {
                        applyFloydSteinberg(imgData.data, activePalette);
                        ditheringName = 'Floyd-Steinberg (Granulado)';
                    } else if (ditheringMode === 'bayer') {
                        applyBayerDithering(imgData.data, activePalette);
                        ditheringName = 'Bayer 4x4 (Patr√≥n S√≥lido)';
                    } else if (ditheringMode === 'jjn') {
                        applyJarvisJudiceNinke(imgData.data, activePalette);
                        ditheringName = 'Jarvis-Judice-Ninke (Alta Calidad)';
                    } else if (ditheringMode === 'stucki') {
                        applyStucki(imgData.data, activePalette);
                        ditheringName = 'Stucki (Buen Balance)';
                    } else if (ditheringMode === 'none') {
                        applyNoDithering(imgData.data, activePalette);
                        ditheringName = 'Umbral Fijo (Ninguno)';
                    }
                    
                    cgaCanvasLabel.innerText = `CGA 4 Colores (${ditheringName})`;
                    ctxCGA.putImageData(imgData, 0, 0);
                    btnConvert.disabled = false; // Habilitar el bot√≥n aqu√≠
                    status.innerText = "‚úÖ Conversi√≥n lista. Compara las im√°genes.";
                } catch(e) {
                    status.innerText = `‚ö†Ô∏è Error al aplicar el dithering: ${e.message}`;
                    btnConvert.disabled = true;
                    console.error("Dithering Error:", e);
                }
            }, 50); 
            
            updateCodeBlock(selectPalette.value);
        }

        // --- Generaci√≥n BSAVE y Descompresi√≥n (Mantienen la l√≥gica original) ---
        
        function generateBsave(pixels) {
            const buffer = new Uint8Array(7 + CGA_MEMORY_SIZE);
            const view = new DataView(buffer.buffer);
            view.setUint8(0, 0xFD); view.setUint16(1, 0x0000, true); 
            view.setUint16(3, 0xB800, true); view.setUint16(5, CGA_MEMORY_SIZE, true); 

            const EVEN_OFFSET = 7;
            const ODD_OFFSET = 7 + CGA_MEMORY_SIZE / 2; 
            const paletteToUse = CGA_PALETTES[selectPalette.value];

            for (let y = 0; y < CGA_HEIGHT; y++) {
                const isOdd = (y % 2 !== 0);
                const lineIndex = Math.floor(y / 2); 
                const baseOffset = isOdd ? ODD_OFFSET : EVEN_OFFSET;
                const lineStart = baseOffset + (lineIndex * 80); 

                for (let x = 0; x < CGA_WIDTH; x += 4) {
                    let byteVal = 0;
                    for (let k = 0; k < 4; k++) {
                        const pixelX = x + k;
                        const idx = ((y * CGA_WIDTH) + pixelX) * 4;
                        let colorIndex = 0; 
                        
                        const r = pixels[idx], g = pixels[idx+1], b = pixels[idx+2];
                        
                        // Buscar el √≠ndice de color correspondiente en la paleta
                        for(let c=0; c<paletteToUse.length; c++) {
                            const pal = paletteToUse[c];
                            if (r === pal.r && g === pal.g && b === pal.b) {
                                colorIndex = pal.index;
                                break;
                            }
                        }
                        // Empaquetar 4 p√≠xeles (2 bits cada uno) en 1 byte
                        byteVal |= (colorIndex << (6 - (k * 2)));
                    }
                    buffer[lineStart + (x / 4)] = byteVal;
                }
            }
            return buffer;
        }
        
        function processBsave(buffer) {
            const data = new DataView(buffer);

            if (data.getUint8(0) !== 0xFD) {
                status.innerText = "Error: Archivo no parece ser un formato BSAVE v√°lido (Cabecera 0xFD).";
                btnConvert.disabled = true;
                return;
            }

            const imgData = ctxCGA.createImageData(CGA_WIDTH, CGA_HEIGHT);
            const pixels = imgData.data;

            const EVEN_OFFSET = 7;
            const ODD_OFFSET = 7 + CGA_MEMORY_SIZE / 2;
            const paletteToUse = CGA_PALETTES[selectPalette.value];

            for (let y = 0; y < CGA_HEIGHT; y++) {
                const isOdd = (y % 2 !== 0);
                const lineIndex = Math.floor(y / 2);
                const baseOffset = isOdd ? ODD_OFFSET : EVEN_OFFSET;
                const lineStart = baseOffset + (lineIndex * 80);

                for (let x = 0; x < CGA_WIDTH; x += 4) {
                    const byteIndex = lineStart + (x / 4);
                    // Asegurar que no leemos fuera del rango del buffer (aunque CGA_MEMORY_SIZE deber√≠a cubrirlo)
                    if (byteIndex >= data.byteLength) continue; 

                    const byteVal = data.getUint8(byteIndex);

                    for (let k = 0; k < 4; k++) {
                        const colorIndex = (byteVal >> (6 - (k * 2))) & 0x03;
                        const color = paletteToUse[colorIndex];

                        const pixelIndex = ((y * CGA_WIDTH) + (x + k)) * 4;
                        
                        pixels[pixelIndex] = color.r; pixels[pixelIndex + 1] = color.g;
                        pixels[pixelIndex + 2] = color.b; pixels[pixelIndex + 3] = 255; 
                    }
                }
            }
            
            ctxCGA.putImageData(imgData, 0, 0);
            ctxOrig.putImageData(imgData, 0, 0); 
            
            btnConvert.disabled = false;
            status.innerText = `‚úÖ Conversi√≥n lista. Descarga el PNG de ${CGA_WIDTH}x${CGA_HEIGHT}.`;
            updateCodeBlock(selectPalette.value);
        }


        // === CONTROLADORES DE EVENTOS ===

        modeRadios.forEach(radio => radio.addEventListener('change', (e) => updateMode(e.target.value)));

        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) {
                 status.innerText = 'Selecciona una imagen...';
                 return;
            }

            fileName = file.name.split('.')[0];
            ctxOrig.clearRect(0, 0, CGA_WIDTH, CGA_HEIGHT);
            ctxCGA.clearRect(0, 0, CGA_WIDTH, CGA_HEIGHT);
            currentImage = null; 
            btnConvert.disabled = true;

            if (currentMode === 'pngToBsave') {
                status.innerText = 'Cargando imagen...';
                const url = URL.createObjectURL(file);

                // Funci√≥n que devuelve una promesa para esperar la carga de la imagen
                const loadImage = () => new Promise((resolve, reject) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error('Error al cargar la imagen.'));
                    img.src = url;
                });
                
                try {
                    const img = await loadImage();
                    currentImage = img; 
                    processImage(img);
                    URL.revokeObjectURL(url);
                } catch (error) {
                    status.innerText = `‚ö†Ô∏è Error: ${error.message}`;
                    console.error(error);
                    URL.revokeObjectURL(url);
                }

            } else if (currentMode === 'bsaveToPng') {
                status.innerText = 'Cargando archivo BSAVE...';
                try {
                    const buffer = await file.arrayBuffer();
                    processBsave(buffer);
                } catch (error) {
                    status.innerText = `‚ö†Ô∏è Error al leer el archivo BSAVE: ${error.message}`;
                    console.error(error);
                }
            }
        });

        // Evento de cambio de Checkbox (Redimensionamiento)
        chkResize.addEventListener('change', () => {
            if (currentMode === 'pngToBsave' && currentImage) {
                processImage(currentImage);
            }
        });
        
        // Evento de cambio de Paleta
        selectPalette.addEventListener('change', () => {
            if (currentMode === 'pngToBsave' && currentImage) {
                processImage(currentImage);
            } else if (currentMode === 'bsaveToPng' && fileInput.files.length > 0) {
                 // Disparar la recarga del archivo BSAVE con la nueva paleta
                 const file = fileInput.files[0];
                 file.arrayBuffer().then(processBsave).catch(error => {
                    status.innerText = `‚ö†Ô∏è Error al re-procesar BSAVE: ${error.message}`;
                    console.error(error);
                 });
            }
            updateCodeBlock(selectPalette.value);
        });
        
        // Evento de cambio de Dithering
        selectDithering.addEventListener('change', () => {
            if (currentMode === 'pngToBsave' && currentImage) {
                processImage(currentImage);
            }
        });


        // === CONTROLADOR DE DESCARGA ===
        btnConvert.addEventListener('click', () => {
            if (btnConvert.disabled) return;
            
            if (currentMode === 'pngToBsave') {
                try {
                    const imgData = ctxCGA.getImageData(0, 0, CGA_WIDTH, CGA_HEIGHT);
                    const buffer = generateBsave(imgData.data);
                    
                    const blob = new Blob([buffer], { type: "application/octet-stream" });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = fileName + "_CGA.BSV";
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } catch(e) {
                    status.innerText = `‚ö†Ô∏è Error al generar BSAVE: ${e.message}`;
                    console.error("BSAVE Generation Error:", e);
                }
            } else if (currentMode === 'bsaveToPng') {
                const link = document.createElement('a');
                link.download = fileName + "_CGA.png";
                link.href = canvasCGA.toDataURL('image/png');
                link.click();
            }
        });
        
        // Inicializaci√≥n
        updateMode(currentMode); 
    </script>
</body>
</html>
