SUB ScrollLeftPixelDefinitivo (FondoByte AS BYTE)
    
    DIM ODD_SEGMENT AS WORD   ' B800h + 2000h = BA00h
    DIM X AS INTEGER
    DIM CurrentByte AS BYTE, NextByte AS BYTE
    DIM NextPixelTemp AS WORD 
    DIM FinalByte AS BYTE
    DIM LastByte AS BYTE
    
    ' Calcular el segmento de inicio de las líneas impares:
    ' &HB800 + &H2000 = &HBA00
    ODD_SEGMENT = &HBA00 
    
    ' ---------------------------------------------
    ' 1. SCROLL DE LÍNEAS PARES (Y = 0, 2, 4, ...)
    ' ---------------------------------------------
    DEF SEG = &HB800 ' Segmento inicial

    FOR Y = 0 TO 198 STEP 2 ' Itera solo sobre las líneas pares
        
        ' El desplazamiento (TargetOffset) es simplemente la posición X * LINE_BYTES,
        ' pero como el código se ejecuta en PowerBasic, trabajamos con offsets (0-79)

        FOR X = 0 TO 78 ' Byte 0 a Byte 78
            
            ' La dirección aquí es 0 (BaseOffset) + Desplazamiento X + (Y/2 * 80)
            ' ¡CRÍTICO! Necesitamos el offset dentro del bloque de 8K.
            ' El CGA entrelaza en hardware, el offset es solo el X.
            
            CurrentByte = PEEK(X)
            NextByte = PEEK(X + 1)

            ' Manipulación de Bits (Scroll de 1 píxel)
            FinalByte = CurrentByte
            SHIFT LEFT FinalByte, 2 
            NextPixelTemp = NextByte : SHIFT RIGHT NextPixelTemp, 6 
            FinalByte = FinalByte OR NextPixelTemp
            
            POKE X, FinalByte
        NEXT X
        
        ' Manejar el último byte (X=79)
        LastByte = PEEK(79)
        NextPixelTemp = LastByte : SHIFT LEFT NextPixelTemp, 2
        LastByte = NextPixelTemp OR FondoByte 
        POKE 79, LastByte
    NEXT Y

    ' ---------------------------------------------
    ' 2. SCROLL DE LÍNEAS IMPARES (Y = 1, 3, 5, ...)
    ' ---------------------------------------------
    DEF SEG = ODD_SEGMENT ' Cambiar al segmento &HBA00

    FOR Y = 1 TO 199 STEP 2 ' Itera solo sobre las líneas impares
        ' Dentro de este segmento, el offset vuelve a ser 0.
        
        FOR X = 0 TO 78 ' Byte 0 a Byte 78
            
            CurrentByte = PEEK(X)
            NextByte = PEEK(X + 1)

            ' Manipulación de Bits
            FinalByte = CurrentByte
            SHIFT LEFT FinalByte, 2 
            NextPixelTemp = NextByte : SHIFT RIGHT NextPixelTemp, 6 
            FinalByte = FinalByte OR NextPixelTemp
            
            POKE X, FinalByte
        NEXT X
        
        ' Manejar el último byte (X=79)
        LastByte = PEEK(79)
        NextPixelTemp = LastByte : SHIFT LEFT NextPixelTemp, 2
        LastByte = NextPixelTemp OR FondoByte 
        POKE 79, LastByte
    NEXT Y

END SUB
