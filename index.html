<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Retro Graphics Converter Ultimate (VGA Edition)</title>
    <style>
        body { font-family: 'Courier New', monospace; background: #1a1a1a; color: #0f0; display: flex; flex-direction: column; align-items: center; padding: 20px; position: relative; }
        .main-container { background: #333; padding: 20px; border: 2px solid #555; border-radius: 8px; text-align: center; width: 95%; max-width: 950px; margin-top: 20px; }
        .mode-selection { display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        .mode-selection input { display: none; }
        .mode-selection label { padding: 10px 20px; background: #222; border: 1px solid #555; cursor: pointer; border-radius: 4px; transition: 0.2s; }
        .mode-selection input:checked + label { background: #aa00aa; color: #fff; border-color: #f0f; box-shadow: 0 0 10px #aa00aa; }
        .controls-area { background: #222; padding: 15px; border-radius: 5px; margin-bottom: 20px; display: flex; flex-direction: column; gap: 15px; }
        .settings-row { display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; align-items: center; }
        select, button { padding: 5px 10px; background: #444; color: #fff; border: 1px solid #666; cursor: pointer; }
        button { background: #aa00aa; font-weight: bold; border: none; padding: 10px 20px; font-size: 1.1em; }
        button:disabled { background: #555; opacity: 0.5; cursor: not-allowed; }
        .canvas-container { display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; margin-top: 20px; }
        .canvas-box { display: flex; flex-direction: column; align-items: center; }
        canvas { border: 2px solid #fff; background: #000; image-rendering: pixelated; width: auto; height: auto; max-width: 100%; }
        .aspect-cpc-m0, .aspect-cpc-m1, .aspect-cga, .aspect-vga { width: 640px; height: 400px; }
        .aspect-spec { width: 512px; height: 384px; }
        .label-tag { background: #000; color: #fff; padding: 2px 8px; font-size: 0.8em; margin-bottom: 5px; border-radius: 3px; }
        .code-block { background: #111; border: 1px solid #444; padding: 10px; text-align: left; margin-top: 20px; font-size: 0.8em; color: #ccc; overflow-x: auto; max-height: 400px; }
        .control-panel { display:none; border-left: 1px solid #555; padding-left: 15px; margin-left: 10px; }
        .credits-link { position: absolute; top: 15px; right: 20px; color: #666; text-decoration: none; font-size: 0.8rem; transition: color 0.3s; z-index: 1000; }
        .credits-link:hover { color: #aa00aa; text-shadow: 0 0 5px #aa00aa; }
    </style>
</head>
<body>

    <a href="https://github.com/githubfito/PNG2BSAVE/tree/main" target="_blank" class="credits-link">by Fitosoft 2025</a>

    <div class="main-container">
        <h1>Retro Graphics Converter</h1>
        <div class="mode-selection">
            <input type="radio" id="mCGA" name="mode" value="cga"> <label for="mCGA">CGA</label>
            <input type="radio" id="mSpec" name="mode" value="spec" checked> <label for="mSpec">Spectrum</label>
            <input type="radio" id="mCPC" name="mode" value="cpc"> <label for="mCPC">Amstrad CPC</label>
            <input type="radio" id="mVGA" name="mode" value="vga"> <label for="mVGA">VGA (M13h)</label>
        </div>
        <div class="controls-area">
            <div class="settings-row">
                <input type="file" id="fileInput" accept="image/*">
                <div><input type="checkbox" id="chkResize" checked> <label for="chkResize">Estirar (Full)</label></div>
            </div>
            <div class="settings-row" id="algosRow">
                <label>Dithering:</label>
                <select id="selDither">
                    <option value="bayer" selected>Bayer</option>
                    <option value="fs">Floyd-Steinberg</option>
                    <option value="jjn">Jarvis-Judice-Ninke</option>
                    <option value="none">Ninguno</option>
                </select>
                <div id="cpcControls" class="control-panel">
                    <label style="color:#f0f;">Modo:</label> <select id="selCpcMode"><option value="0">Modo 0 (16 Col.)</option><option value="1">Modo 1 (4 Col.)</option></select>
                </div>
                <div id="cgaControls" class="control-panel">
                    <select id="selCgaPal"><option value="p1">Paleta 1 (Cian)</option><option value="p2">Paleta 2 (Rojo)</option></select>
                </div>
                <div id="specControls" class="control-panel">
                    <input type="checkbox" id="chkMono"> <label for="chkMono">B/N</label>
                </div>
                <div id="vgaControls" class="control-panel">
                    <label style="color:#ff0;">Paleta:</label> 
                    <select id="selVgaType"><option value="opt">Optimizada (256)</option><option value="std">EstÃ¡ndar (Web)</option></select>
                </div>
            </div>
            <div class="settings-row"><button id="btnDownload" disabled>ðŸ’¾ Descargar Resultado</button></div>
            <div id="status">Esperando imagen...</div>
        </div>
        <div class="canvas-container">
            <div class="canvas-box"><span class="label-tag">Original</span><canvas id="cvsOrig"></canvas></div>
            <div class="canvas-box"><span class="label-tag">Resultado Retro</span><canvas id="cvsDest"></canvas></div>
        </div>
        <div class="code-block"><strong id="codeTitle">Loader Code:</strong><pre id="codeOutput">...</pre></div>
    </div>

    <script>
        // === CONFIGURACIÃ“N Y TABLAS ===
        function getLuma(r, g, b) { return 0.299*r + 0.587*g + 0.114*b; }
        function getDistRGB(r1, g1, b1, r2, g2, b2) { return (r1-r2)**2 + (g1-g2)**2 + (b1-b2)**2; }
        function clamp(v) { return Math.max(0, Math.min(255, v)); }

        const PAL_SPEC = [
            {r:0,g:0,b:0}, {r:0,g:0,b:215}, {r:215,g:0,b:0}, {r:215,g:0,b:215},
            {r:0,g:215,b:0}, {r:0,g:215,b:215}, {r:215,g:215,b:0}, {r:215,g:215,b:215},
            {r:0,g:0,b:0}, {r:0,g:0,b:255}, {r:255,g:0,b:0}, {r:255,g:255,b:255},
            {r:0,g:255,b:0}, {r:0,g:255,b:255}, {r:255,g:255,b:0}, {r:255,g:255,b:255}
        ];

        const PAL_CGA = {
            p1: [{r:0,g:0,b:0}, {r:85,g:255,b:255}, {r:255,g:85,b:255}, {r:255,g:255,b:255}],
            p2: [{r:0,g:0,b:0}, {r:85,g:255,b:85}, {r:255,g:85,b:85}, {r:255,g:255,b:85}]
        };

        const CPC_HW = [{hw:0,r:0,g:0,b:0}, {hw:1,r:0,g:0,b:128}, {hw:2,r:0,g:0,b:255}, {hw:3,r:128,g:0,b:0}, {hw:4,r:128,g:0,b:128}, {hw:5,r:128,g:0,b:255}, {hw:6,r:255,g:0,b:0}, {hw:7,r:255,g:0,b:128}, {hw:8,r:255,g:0,b:255}, {hw:9,r:0,g:128,b:0}, {hw:10,r:0,g:128,b:128}, {hw:11,r:0,g:128,b:255}, {hw:12,r:128,g:128,b:0}, {hw:13,r:128,g:128,b:128}, {hw:14,r:128,g:128,b:255}, {hw:15,r:255,g:128,b:0}, {hw:16,r:255,g:128,b:128}, {hw:17,r:255,g:128,b:255}, {hw:18,r:0,g:255,b:0}, {hw:19,r:0,g:255,b:128}, {hw:20,r:0,g:255,b:255}, {hw:21,r:128,g:255,b:0}, {hw:22,r:128,g:255,b:128}, {hw:23,r:128,g:255,b:255}, {hw:24,r:255,g:255,b:0}, {hw:25,r:255,g:255,b:128}, {hw:26,r:255,g:255,b:255}];

        const BAYER4 = [[0,8,2,10],[12,4,14,6],[3,11,1,9],[15,7,13,5]];

        let specAttributes = new Uint8Array(768); 
        let state = { mode: 'spec', cpcSubMode: 0, img: null, fileName: 'image', cpcPal: [], vgaPal: [] };
        
        const cvsOrig = document.getElementById('cvsOrig'), cvsDest = document.getElementById('cvsDest');
        const ctxOrig = cvsOrig.getContext('2d'), ctxDest = cvsDest.getContext('2d', { willReadFrequently: true });

        function init() {
            document.querySelectorAll('input[name="mode"]').forEach(r => r.addEventListener('change', e => updateUI(e.target.value)));
            document.getElementById('fileInput').addEventListener('change', e => {
                const f = e.target.files[0]; if (!f) return;
                state.fileName = f.name.split('.')[0].replace(/[^a-z0-9]/gi, '_');
                const img = new Image(); img.onload = () => { state.img = img; process(); }; img.src = URL.createObjectURL(f);
            });
            ['chkResize', 'selDither', 'selCgaPal', 'chkMono', 'selCpcMode', 'selVgaType'].forEach(id => document.getElementById(id).addEventListener('change', process));
            document.getElementById('btnDownload').addEventListener('click', download);
            updateUI('spec');
        }

        function updateUI(m) {
            state.mode = m;
            document.getElementById('cgaControls').style.display = (m==='cga') ? 'block' : 'none';
            document.getElementById('specControls').style.display = (m==='spec') ? 'block' : 'none';
            document.getElementById('cpcControls').style.display = (m==='cpc') ? 'block' : 'none';
            document.getElementById('vgaControls').style.display = (m==='vga') ? 'block' : 'none';
            process();
        }

        function process() {
            if (!state.img) return;
            document.getElementById('status').innerText = "Procesando...";
            setTimeout(() => {
                let w, h, cssClass;
                state.cpcSubMode = parseInt(document.getElementById('selCpcMode').value);

                if (state.mode === 'cpc') {
                    if (state.cpcSubMode === 0) { w = 160; h = 200; cssClass = 'aspect-cpc-m0'; }
                    else { w = 320; h = 200; cssClass = 'aspect-cpc-m1'; }
                } else if (state.mode === 'spec') { w = 256; h = 192; cssClass = 'aspect-spec'; }
                else if (state.mode === 'vga') { w = 320; h = 200; cssClass = 'aspect-vga'; }
                else { w = 320; h = 200; cssClass = 'aspect-cga'; }

                cvsOrig.width = cvsDest.width = w; cvsOrig.height = cvsDest.height = h;
                cvsOrig.className = cvsDest.className = cssClass;
                
                ctxOrig.fillStyle = '#000'; ctxOrig.fillRect(0,0,w,h);
                if (document.getElementById('chkResize').checked) ctxOrig.drawImage(state.img, 0, 0, w, h);
                else {
                    const r = Math.min(w/state.img.width, h/state.img.height);
                    ctxOrig.drawImage(state.img, (w-state.img.width*r)/2, (h-state.img.height*r)/2, state.img.width*r, state.img.height*r);
                }

                let activePalette = [];
                if (state.mode === 'cpc') {
                    state.cpcPal = detectCpcPalette(ctxOrig, w, h, state.cpcSubMode === 0 ? 16 : 4);
                    activePalette = state.cpcPal;
                } else if (state.mode === 'spec') activePalette = PAL_SPEC;
                else if (state.mode === 'vga') {
                    state.vgaPal = detectVgaPalette(ctxOrig, w, h, 256);
                    activePalette = state.vgaPal;
                }
                else activePalette = PAL_CGA[document.getElementById('selCgaPal').value];

                const imgData = ctxOrig.getImageData(0,0,w,h);
                const data = imgData.data;
                const algo = document.getElementById('selDither').value;

                if (state.mode === 'spec') {
                    if (document.getElementById('chkMono').checked) applyMonochrome(data);
                    else applySpectrumV11(data, w, h, algo);
                } else {
                    switch(algo) {
                        case 'fs': applyFloydSteinberg(data, activePalette, w, h); break;
                        case 'bayer': applyBayer(data, activePalette, w, h); break;
                        case 'jjn': applyJJN(data, activePalette, w, h); break;
                        default: applyNearest(data, activePalette); break;
                    }
                }
                ctxDest.putImageData(imgData, 0, 0);
                updateCodeBlock();
                document.getElementById('status').innerText = "âœ… Listo";
                document.getElementById('btnDownload').disabled = false;
            }, 10);
        }

        // --- PALETTE DETECTORS ---
        function detectCpcPalette(ctx, w, h, limit) {
            const d = ctx.getImageData(0,0,w,h).data, hwCounts = {}; 
            for(let i=0; i<d.length; i+=4) {
                const r=d[i], g=d[i+1], b=d[i+2];
                let bestHw=0, minD=Infinity;
                for(let c of CPC_HW) { const dist = getDistRGB(r, g, b, c.r, c.g, c.b); if(dist < minD) { minD = dist; bestHw = c.hw; } }
                hwCounts[bestHw] = (hwCounts[bestHw] || 0) + 1;
            }
            const sortedHwIds = Object.keys(hwCounts).sort((a,b) => hwCounts[b] - hwCounts[a]).slice(0,limit);
            const pal = sortedHwIds.map((hwId, idx) => { const c = CPC_HW.find(x => x.hw == hwId); return { index: idx, hw: c.hw, r: c.r, g: c.g, b: c.b }; });
            while(pal.length < limit) pal.push({index:pal.length, hw:0, r:0, g:0, b:0});
            return pal;
        }

        function detectVgaPalette(ctx, w, h, limit) {
            if(document.getElementById('selVgaType').value === 'std') {
                let p = []; for(let i=0; i<256; i++) p.push({r:i, g:i, b:i}); return p; // Gris como fallback
            }
            const d = ctx.getImageData(0,0,w,h).data, counts = {};
            for(let i=0; i<d.length; i+=4) {
                const r=d[i]>>3, g=d[i+1]>>3, b=d[i+2]>>3; // Cuantizar para agrupar
                const key = (r<<10)|(g<<5)|b;
                counts[key] = (counts[key] || 0) + 1;
            }
            const sorted = Object.keys(counts).sort((a,b) => counts[b] - counts[a]).slice(0, limit);
            return sorted.map((key, idx) => {
                return { r: (key >> 10) << 3, g: ((key >> 5) & 31) << 3, b: (key & 31) << 3, index: idx };
            });
        }

        // --- ENGINES ---
        function getClosestIdx(r,g,b, pal) {
            let min = Infinity, idx = 0;
            for(let i=0; i<pal.length; i++) {
                const d = getDistRGB(r, g, b, pal[i].r, pal[i].g, pal[i].b);
                if(d < min) { min = d; idx = i; }
            }
            return idx;
        }

        function applyNearest(d, pal) { for(let i=0; i<d.length; i+=4) { const c = pal[getClosestIdx(d[i], d[i+1], d[i+2], pal)]; d[i]=c.r; d[i+1]=c.g; d[i+2]=c.b; } }
        function applyMonochrome(d) { for(let i=0; i<d.length; i+=4) { const v = getLuma(d[i],d[i+1],d[i+2]) > 127 ? 255 : 0; d[i]=v; d[i+1]=v; d[i+2]=v; } }

        function applySpectrumV11(data, w, h, algo) {
            // --- CORRECCIÃ“N: Separar pares por nivel de brillo ---
            // Solo permitimos pares donde ambos colores sean Normales (0-7)
            // o ambos colores sean Brillantes (8-15).
            const normalPairs = [];
            for(let i=0; i<8; i++) for(let j=i; j<8; j++) normalPairs.push([i,j]);

            const brightPairs = [];
            for(let i=8; i<16; i++) for(let j=i; j<16; j++) brightPairs.push([i,j]);

            for (let by = 0; by < h; by += 8) {
                for (let bx = 0; bx < w; bx += 8) {
                    // 1. Recopilar los pÃ­xeles del bloque 8x8 actual
                    const blockOrig = [];
                    for (let y=0;y<8;y++) for (let x=0;x<8;x++) {
                        if(bx+x >= w || by+y >= h) continue; // Evitar salir del canvas
                        const i = ((by+y)*w + (bx+x))*4;
                        blockOrig.push({r:data[i], g:data[i+1], b:data[i+2], idx:i, x:x, y:y});
                    }
                    if(blockOrig.length === 0) continue;

                    // FunciÃ³n auxiliar para encontrar el mejor par dentro de una lista dada
                    const findBestInList = (pairsList) => {
                        let bestP = pairsList[0], minE = Infinity;
                        for (const pair of pairsList) {
                            const c1 = PAL_SPEC[pair[0]], c2 = PAL_SPEC[pair[1]];
                            // Color promedio para evaluar contraste
                            const mixR = (c1.r+c2.r)/2, mixG = (c1.g+c2.g)/2, mixB = (c1.b+c2.b)/2;
                            let currentErr = 0;
                            for(const p of blockOrig) {
                                const d1 = getDistRGB(p.r, p.g, p.b, c1.r, c1.g, c1.b);
                                const d2 = getDistRGB(p.r, p.g, p.b, c2.r, c2.g, c2.b);
                                const dM = getDistRGB(p.r, p.g, p.b, mixR, mixG, mixB);
                                // Usamos una mezcla ponderada del error a los extremos y al centro
                                currentErr += Math.min(d1, d2, dM * 0.6);
                            }
                            if (currentErr < minE) { minE = currentErr; bestP = pair; }
                        }
                        return { pair: bestP, err: minE };
                    };

                    // 2. Buscar el mejor candidato normal y el mejor brillante
                    const resNormal = findBestInList(normalPairs);
                    const resBright = findBestInList(brightPairs);

                    // 3. Decidir ganador y establecer el bit de brillo
                    let finalPair, isBrightBit;
                    // Damos una ligerÃ­sima preferencia a los colores normales si el error es muy similar
                    // para evitar una imagen excesivamente brillante.
                    if (resNormal.err <= resBright.err * 1.05) {
                         finalPair = resNormal.pair; isBrightBit = 0;
                    } else {
                         finalPair = resBright.pair; isBrightBit = 64;
                    }

                    const inkIdx = finalPair[0], paperIdx = finalPair[1];

                    // Guardar el byte de atributo (Flash, Brillo, Papel, Tinta)
                    specAttributes[(by/8)*32 + (bx/8)] = isBrightBit | ((paperIdx % 8) << 3) | (inkIdx % 8);

                    // 4. Aplicar Dithering y dibujar los pÃ­xeles finales
                    const ink = PAL_SPEC[inkIdx], paper = PAL_SPEC[paperIdx];
                    for(const p of blockOrig) {
                        const i = p.idx;
                        // He reducido ligeramente la fuerza del dither Bayer (de 80 a 65) 
                        // para que sea un poco mÃ¡s limpio con la nueva paleta.
                        let dv = (algo === 'bayer') ? (BAYER4[p.y%4][p.x%4]/16 - 0.5) * 65 : 0;
                        const d1 = getDistRGB(p.r+dv, p.g+dv, p.b+dv, ink.r, ink.g, ink.b);
                        const d2 = getDistRGB(p.r+dv, p.g+dv, p.b+dv, paper.r, paper.g, paper.b);
                        const finalC = (d1 < d2) ? ink : paper;
                        data[i] = finalC.r; data[i+1] = finalC.g; data[i+2] = finalC.b;
                    }
                }
            }
        }

        // --- DITHERING ---
        function addErr(d, i, er, eg, eb, f) { d[i] = clamp(d[i] + er*f); d[i+1] = clamp(d[i+1] + eg*f); d[i+2] = clamp(d[i+2] + eb*f); }
        function applyFloydSteinberg(d, pal, w, h) {
            for(let y=0; y<h; y++) for(let x=0; x<w; x++) {
                const i = (y*w+x)*4, c = pal[getClosestIdx(d[i],d[i+1],d[i+2], pal)];
                const er=d[i]-c.r, eg=d[i+1]-c.g, eb=d[i+2]-c.b;
                d[i]=c.r; d[i+1]=c.g; d[i+2]=c.b;
                if(x+1<w) addErr(d, (y*w+x+1)*4, er,eg,eb, 7/16);
                if(x>0 && y+1<h) addErr(d, ((y+1)*w+x-1)*4, er,eg,eb, 3/16);
                if(y+1<h) addErr(d, ((y+1)*w+x)*4, er,eg,eb, 5/16);
                if(x+1<w && y+1<h) addErr(d, ((y+1)*w+x+1)*4, er,eg,eb, 1/16);
            }
        }
        function applyBayer(d, pal, w, h) {
            for(let y=0; y<h; y++) for(let x=0; x<w; x++) {
                const i = (y*w+x)*4, t = (BAYER4[y%4][x%4]/16)-0.5, f=40;
                const c = pal[getClosestIdx(clamp(d[i]+t*f), clamp(d[i+1]+t*f), clamp(d[i+2]+t*f), pal)];
                d[i]=c.r; d[i+1]=c.g; d[i+2]=c.b;
            }
        }
        function applyJJN(d, pal, w, h) {
             const m = [{dx:1, dy:0, f:7}, {dx:2, dy:0, f:5}, {dx:-2, dy:1, f:3}, {dx:-1, dy:1, f:5}, {dx:0, dy:1, f:7}, {dx:1, dy:1, f:5}, {dx:2, dy:1, f:3}, {dx:-2, dy:2, f:1}, {dx:-1, dy:2, f:3}, {dx:0, dy:2, f:5}, {dx:1, dy:2, f:3}, {dx:2, dy:2, f:1}];
             for(let y=0; y<h; y++) for(let x=0; x<w; x++) {
                const i=(y*w+x)*4, c=pal[getClosestIdx(d[i],d[i+1],d[i+2],pal)];
                const er=d[i]-c.r, eg=d[i+1]-c.g, eb=d[i+2]-c.b;
                d[i]=c.r; d[i+1]=c.g; d[i+2]=c.b;
                for(let k of m) { const nx=x+k.dx, ny=y+k.dy; if(nx>=0 && nx<w && ny<h) addErr(d, (ny*w+nx)*4, er,eg,eb, k.f/48); }
             }
        }

        // --- EXPORTERS ---
        function download() {
            if(!state.img) return;
            const px = ctxDest.getImageData(0,0,cvsDest.width, cvsDest.height).data;
            let blob, ext;
            if (state.mode === 'cpc') { blob = new Blob([genCpcBin(px)], {type: 'application/octet-stream'}); ext = '.BIN'; }
            else if (state.mode === 'spec') { blob = new Blob([genSpecScr(px)], {type: 'application/octet-stream'}); ext = '.SCR'; }
            else if (state.mode === 'vga') { blob = new Blob([genVgaBin(px)], {type: 'application/octet-stream'}); ext = '.VGA'; }
            else { blob = new Blob([genCgaBsave(px)], {type: 'application/octet-stream'}); ext = '.BSV'; }
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = state.fileName + ext; a.click();
        }

        function genVgaBin(px) {
            const buf = new Uint8Array(64000 + 768);
            for(let i=0; i<64000; i++) buf[i] = getClosestIdx(px[i*4], px[i*4+1], px[i*4+2], state.vgaPal);
            for(let i=0; i<256; i++) {
                if(state.vgaPal[i]) {
                    buf[64000 + i*3] = state.vgaPal[i].r >> 2;
                    buf[64000 + i*3+1] = state.vgaPal[i].g >> 2;
                    buf[64000 + i*3+2] = state.vgaPal[i].b >> 2;
                }
            }
            return buf;
        }

        function genCpcBin(px) {
            const buf = new Uint8Array(16384), isM1 = (state.cpcSubMode === 1);
            for(let y=0; y<200; y++) {
                const lineAddr = ((y >> 3) * 80) + ((y & 7) * 2048);
                for(let xByte=0; xByte<80; xByte++) {
                    let byte = 0;
                    if (!isM1) { 
                        const c1 = getClosestIdx(px[(y*160+xByte*2)*4], px[(y*160+xByte*2)*4+1], px[(y*160+xByte*2)*4+2], state.cpcPal);
                        const c2 = getClosestIdx(px[(y*160+xByte*2+1)*4], px[(y*160+xByte*2+1)*4+1], px[(y*160+xByte*2+1)*4+2], state.cpcPal);
                        if(c1&1) byte|=128; if(c1&2) byte|=8; if(c1&4) byte|=32; if(c1&8) byte|=2;
                        if(c2&1) byte|=64;  if(c2&2) byte|=4; if(c2&4) byte|=16; if(c2&8) byte|=1;
                    } else { 
                        for(let p=0; p<4; p++) {
                            const c = getClosestIdx(px[(y*320+xByte*4+p)*4], px[(y*320+xByte*4+p)*4+1], px[(y*320+xByte*4+p)*4+2], state.cpcPal);
                            if(c & 2) byte |= (1 << (7-p)); if(c & 1) byte |= (1 << (3-p));
                        }
                    }
                    buf[lineAddr + xByte] = byte;
                }
            }
            return buf;
        }

        function genSpecScr(px) {
            const buf = new Uint8Array(6912);
            for (let by=0; by<24; by++) {
                for (let bx=0; bx<32; bx++) {
                    const attr = specAttributes[by*32 + bx];
                    buf[6144 + by*32 + bx] = attr;
                    const cInk = PAL_SPEC[(attr & 7) + ((attr & 64) ? 8 : 0)];
                    const cPaper = PAL_SPEC[((attr >> 3) & 7) + ((attr & 64) ? 8 : 0)];
                    for(let y=0;y<8;y++) {
                        const addr = (((by*8+y)>>6)<<11) + (((by*8+y)&7)<<8) + (((by*8+y)>>3&7)<<5);
                        let byte=0;
                        for(let x=0;x<8;x++) {
                            const i=((by*8+y)*256+(bx*8+x))*4;
                            if(getDistRGB(px[i],px[i+1],px[i+2], cInk.r,cInk.g,cInk.b) < getDistRGB(px[i],px[i+1],px[i+2], cPaper.r,cPaper.g,cPaper.b)) byte |= (1<<(7-x));
                        }
                        buf[addr+bx] = byte;
                    }
                }
            }
            return buf;
        }

        function genCgaBsave(px) {
            const buf = new Uint8Array(16391); buf[0]=0xFD; buf.set([0,0,0,184,0,64],1);
            const pal = PAL_CGA[document.getElementById('selCgaPal').value];
            for(let y=0; y<200; y++) {
                const off = 7 + (y%2?0x2000:0) + (Math.floor(y/2)*80);
                for(let x=0; x<80; x++) {
                    let b = 0;
                    for(let p=0; p<4; p++) b |= (getClosestIdx(px[(y*320+x*4+p)*4],px[(y*320+x*4+p)*4+1],px[(y*320+x*4+p)*4+2], pal) << (6-p*2));
                    buf[off+x] = b;
                }
            }
            return buf;
        }

        function updateCodeBlock() {
            const t=document.getElementById('codeTitle'), o=document.getElementById('codeOutput'), f=state.fileName.toUpperCase();
            if (state.mode === 'cpc') {
                t.innerText = "AMSTRAD CPC LOADER:"; o.innerText = `10 MODE ${state.cpcSubMode}\n20 MEMORY &3FFF: LOAD "${f}.BIN",&C000\n30 CALL &C000: GOTO 30`;
            } else if (state.mode === 'spec') {
                t.innerText = "ZX SPECTRUM LOADER:"; o.innerText = `10 CLEAR 24999: LOAD "" SCREEN$\n20 PAUSE 0`;
            } else if (state.mode === 'vga') {
                // *** BLOQUE POWERBASIC ACTUALIZADO ***
                t.innerText = "POWERBASIC (VGA M13H):"; 
                o.innerText = `' =================================================            
' CARGADOR VGA OPTIMIZADO - SINTAXIS REG CORREGIDA
' =================================================            
$CPU 8086
$FLOAT EMULATE

DEFINT A-Z

' --- ConfiguraciÃ³n inicial ---
CLS
f$ = "vga.bin"

IF LEN(DIR$(f$)) = 0 THEN
    PRINT "Error: El archivo '" + f$ + "' no existe."
    END
END IF

' --- Activar Modo 13h (320x200 256 colores) ---
' Sintaxis PB 3.5: REG 1 es AX.
' Cargamos &H0013 en AX (AH=00, AL=13)
REG 1, &H0013
CALL INTERRUPT &H10

' --- Cargar Datos (Rutina RÃ¡pida) ---
LoadVGAFast f$

' --- Esperar tecla ---
WHILE INKEY$ = "": WEND

' --- Volver a modo texto (Modo 3 estÃ¡ndar) ---
' Cargamos &H0003 en AX
REG 1, &H0003
CALL INTERRUPT &H10
END

' =================================================            
SUB LoadVGAFast(FileName$)
    DIM f AS INTEGER
    DIM buffer AS STRING
    DIM palBuffer AS STRING
    
    f = FREEFILE
    OPEN FileName$ FOR BINARY AS #f    
    
    ' --- PARTE 1: PIXELES ---
    DEF SEG = &HA000
    
    ' Buffer de 32000 bytes para evitar overflow de integer
    buffer = SPACE$(32000)
    
    ' Mitad superior
    GET$ #f, 32000, buffer   
    POKE$ 0, buffer          
    
    ' Mitad inferior
    GET$ #f, 32000, buffer
    POKE$ 32000, buffer      
    
    ' --- PARTE 2: PALETA ---
    palBuffer = SPACE$(768)
    GET$ #f, 768, palBuffer
    
    ' Puerto 3C8h: Indice de color (empezamos en 0)
    OUT &H3C8, 0
    FOR i = 1 TO 768
        ' Puerto 3C9h: Datos RGB
        OUT &H3C9, ASC(palBuffer, i)
    NEXT i
    
    CLOSE #f
    DEF SEG
END SUB`;
            } else {
                t.innerText = "GW-BASIC (CGA):"; o.innerText = `10 SCREEN 1: COLOR 0,0: DEF SEG=&HB800\n20 BLOAD "${f}.BSV", 0\n30 IF INKEY$="" THEN 30`;
            }
        }

        init();
    </script>
</body>
</html>
