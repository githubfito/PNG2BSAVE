<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Conversor Gr√°fico Retro (CGA/Spectrum/CPC)</title>
    <style>
        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: #1a1a1a;
            color: #0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .page-header {
            width: 100%;
            max-width: 700px; 
            position: relative;
            text-align: center;
            margin-bottom: 20px; 
        }
        
        h1 { 
            text-shadow: 2px 2px #000; 
            margin-bottom: 0px; 
        }

        .attribution {
            position: absolute;
            top: 5px; 
            right: 0; 
            font-size: 0.75em; 
            color: #555; 
        }

        .attribution a {
            color: #ff55ff; 
            text-decoration: none;
        }

        .attribution a:hover {
            text-decoration: underline;
        }
        
        .main-container {
            background: #333;
            padding: 20px;
            border: 2px solid #555;
            border-radius: 8px;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .mode-selection {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 10px;
            border-bottom: 1px dashed #777;
            padding-bottom: 15px;
            flex-wrap: wrap; 
        }

        .mode-selection input[type="radio"] { display: none; }
        .mode-selection label {
            padding: 8px 15px;
            border: 1px solid #555;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }
        .mode-selection input[type="radio"]:checked + label {
            background-color: #aa00aa;
            border-color: #ff55ff;
            color: #fff;
        }
        .mode-selection label:hover:not(.mode-selection input[type="radio"]:checked + label) {
            background-color: #444;
        }
        
        .controls {
            padding-bottom: 10px;
        }

        .settings-row {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap; 
            justify-content: center;
            align-items: center;
            gap: 15px;
            font-size: 0.9em;
        }
        
        select {
            background-color: #555;
            color: #0f0;
            border: 1px solid #777;
            padding: 5px;
            border-radius: 3px;
            font-family: inherit;
        }
        .settings-row label {
            color: #ccc;
        }


        button {
            background-color: #aa00aa; 
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 18px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            margin-top: 10px;
        }
        button:hover { background-color: #ff55ff; }
        button:disabled { background-color: #555; cursor: not-allowed; }

        .canvas-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            padding-top: 10px; 
            border-top: 1px dashed #777;
        }
        
        .canvas-label {
            background: #000;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.9em;
            color: #fff;
        }

        canvas {
            border: 4px solid #fff;
            image-rendering: pixelated;
            max-width: 640px; 
            max-height: 400px;
            width: 640px; 
            height: 400px;
            background: #000;
        }

        .canvas-spectrum {
             width: 512px; /* 256x2 */
             height: 384px; /* 192x2 */
        }
        
        .canvas-cpc {
             width: 320px; /* 160x2 */
             height: 400px; /* 200x2 */
        }


        .code-block {
            background: #000;
            border: 1px solid #444;
            padding: 15px;
            text-align: left;
            margin-top: 20px;
            width: 100%;
            max-width: 600px;
            font-size: 0.85em;
        }
    </style>
</head>
<body>

    <header class="page-header">
        <h1>PNG ‚Üî BSAVE/SCR/BIN (CGA/Spectrum/CPC)</h1>
        <div class="attribution">
            by <a href="https://github.com/githubfito" target="_blank">fitosoft</a>
        </div>
    </header>

    <div class="main-container">

        <div class="mode-selection">
            <input type="radio" id="modePngToBsave" name="conversionMode" value="pngToBsave">
            <label for="modePngToBsave">1) üñºÔ∏è PNG a .BSV (CGA)</label>

            <input type="radio" id="modeBsaveToPng" name="conversionMode" value="bsaveToPng">
            <label for="modeBsaveToPng">2) üíæ .BSV a PNG (CGA)</label>
            
            <input type="radio" id="modePngToSpectrum" name="conversionMode" value="pngToSpectrum" checked>
            <label for="modePngToSpectrum">3) üëæ PNG a .SCR (Spectrum)</label>
            
            <input type="radio" id="modePngToCpc" name="conversionMode" value="pngToCpc">
            <label for="modePngToCpc">4) üü© PNG a .BIN (CPC)</label>
        </div>
        
        <div class="controls">
            <input type="file" id="fileInput" accept="image/*, .bsv, .scr, .bin">
            
            <div id="pngSettings" class="settings-row" style="display:none;">
                <input type="checkbox" id="chkResize" checked>
                <label for="chkResize">Adaptar a 320x200 (Estirar)</label>
                
                <label for="selectPalette">Paleta:</label>
                <select id="selectPalette">
                    <option value="palette1">Paleta 1 (Cian, Magenta, Blanco)</option>
                    <option value="palette2">Paleta 2 (Verde, Rojo, Marr√≥n)</option>
                    <option value="spectrum">Paleta Spectrum (15 colores)</option>
                    <option value="cpc" style="display:none;">Paleta CPC (16 colores)</option>
                </select>
                
                <label for="selectDithering">Dithering:</label>
                <select id="selectDithering">
                    <option value="floyd-steinberg" selected>Floyd-Steinberg (Granulado)</option>
                    <option value="bayer">Bayer 4x4 (Patr√≥n S√≥lido)</option>
                    <option value="jjn">Jarvis-Judice-Ninke (Alta Calidad)</option>
                    <option value="stucki">Stucki (Buen Balance)</option>
                    <option value="none">Ninguno (Umbral Fijo)</option>
                </select>
            </div>
            
            <div id="spectrumSettings" class="settings-row">
                <input type="checkbox" id="chkResizeSpectrum" checked>
                <label for="chkResizeSpectrum">Adaptar a 256x192 (Estirar)</label>
                
                <input type="checkbox" id="chkMonochrome">
                <label for="chkMonochrome">Forzar Monocromo (Blanco/Negro)</label>
            </div>
            
            <div id="cpcSettings" class="settings-row" style="display:none;">
                <input type="checkbox" id="chkResizeCpc" checked>
                <label for="chkResizeCpc">Adaptar a 160x200 (Estirar)</label>
            </div>

            <p id="status" style="color:#aaa">Selecciona una imagen...</p>
            <button id="btnConvert" disabled>üíæ Descargar .SCR</button>
        </div>


        <div id="canvasOriginalWrapper" class="canvas-wrapper">
            <span class="canvas-label" id="originalCanvasLabel">Original (Redimensionado)</span>
            <canvas id="canvasOriginal" width="256" height="192" class="canvas-spectrum"></canvas>
        </div>

        <div class="canvas-wrapper">
            <span class="canvas-label" id="cgaCanvasLabel">Spectrum 15 Colores (Dithering)</span>
            <canvas id="canvasCGA" width="256" height="192" class="canvas-spectrum"></canvas>
        </div>

    </div>

    <div class="code-block">
        <strong>C√≥digo de Carga (ZX Spectrum BASIC):</strong>
<pre id="codeSnippet" style="color: #ccc; margin:0;">
REM C√≥digo BASIC para ZX Spectrum
10 CLEAR 30000: REM Reserva de memoria
20 LOAD ""SCREEN$ FROM "IMAGEN.SCR"
30 PAUSE 0
</pre>
    </div>

    <script>
        // === DEFINICIONES Y CONSTANTES ===
        const CGA_WIDTH = 320;
        const CGA_HEIGHT = 200;
        const CGA_MEMORY_SIZE = 16384; 
        
        const SPEC_WIDTH = 256;
        const SPEC_HEIGHT = 192;
        const SPEC_SCREEN_SIZE = 6912; // 6144 (pixels) + 768 (atributos)
        
        // --- CONSTANTES AMSTRAD CPC (NUEVAS) ---
        const CPC_WIDTH = 160;
        const CPC_HEIGHT = 200;
        const CPC_VRAM_SIZE = 0x4000; // 16384 bytes
        const CPC_BYTES_PER_LINE = 80;
        // ----------------------------------------
        
        const ZX_SPECTRUM_PALETTE = [
            { r: 0x00, g: 0x00, b: 0x00, index: 0 }, // Black
            { r: 0x00, g: 0x00, b: 0xD7, index: 1 }, // Blue
            { r: 0xD7, g: 0x00, b: 0x00, index: 2 }, // Red
            { r: 0xD7, g: 0x00, b: 0xD7, index: 3 }, // Magenta
            { r: 0x00, g: 0xD7, b: 0x00, index: 4 }, // Green
            { r: 0x00, g: 0xD7, b: 0xD7, index: 5 }, // Cyan
            { r: 0xD7, g: 0xD7, b: 0x00, index: 6 }, // Yellow
            { r: 0xD7, g: 0xD7, b: 0xD7, index: 7 }, // White
            // Bright Colors (index 8-15)
            { r: 0x00, g: 0x00, b: 0x00, index: 8 }, // Bright Black (Same as 0)
            { r: 0x00, g: 0x00, b: 0xFF, index: 9 }, // Bright Blue
            { r: 0xFF, g: 0x00, b: 0x00, index: 10},// Bright Red
            { r: 0xFF, g: 0x00, b: 0xFF, index: 11},// Bright Magenta
            { r: 0x00, g: 0xFF, b: 0x00, index: 12},// Bright Green
            { r: 0x00, g: 0xFF, b: 0xFF, index: 13},// Bright Cyan
            { r: 0xFF, g: 0xFF, b: 0x00, index: 14},// Bright Yellow
            { r: 0xFF, g: 0xFF, b: 0xFF, index: 15} // Bright White
        ];
        
        const CGA_PALETTES = {
            palette1: [
                { r: 0,   g: 0,   b: 0, index: 0 },
                { r: 85,  g: 255, b: 255, index: 1 }, 
                { r: 255, g: 85,  b: 255, index: 2 }, 
                { r: 255, g: 255, b: 255, index: 3 }
            ],
            palette2: [ 
                { r: 0,   g: 0,   b: 0, index: 0 },
                { r: 85,  g: 255, b: 85, index: 1 }, 
                { r: 255, g: 85,  b: 85, index: 2 },  
                { r: 255, g: 255, b: 85, index: 3 }
            ],
            spectrum: ZX_SPECTRUM_PALETTE
        };

        // --- PALETAS CPC (DE PNG2CPC.html) ---
        let pal27 = null;
        let cpcPal16 = null; // Se inicializa en updateMode

        function generateCpc27Palette() {
            const levels = [0x00, 0x80, 0xFF];
            const palette = [];
            for (let r of levels) for (let g of levels) for (let b of levels) palette.push({r,g,b});
            return palette;
        }

        // Modificada para incluir el √≠ndice de hardware (hwIndex)
        function defaultPal16From27(pal27) {
            // Estos son los √≠ndices de hardware (0-26) del CPC
            const hwIndices = [0,2,6,8,12,14,18,20,22,24,26,10,16,4,1,25];
            // Se almacena el penIndex (0-15) y el hwIndex (0-26) para los comandos INK
            return hwIndices.map((hwIndex, penIndex) => ({
                r: pal27[hwIndex].r, 
                g: pal27[hwIndex].g, 
                b: pal27[hwIndex].b, 
                index: penIndex, // Pen number (0-15)
                hwIndex: hwIndex // Hardware color code (0-26)
            })); 
        }
        // ----------------------------------------
        
        const BAYER_MATRIX = [
            [0, 8, 2, 10],
            [12, 4, 14, 6],
            [3, 11, 1, 9],
            [15, 7, 13, 5]
        ];
        const BAYER_SIZE = 4;
        const BAYER_DIVISOR = BAYER_SIZE * BAYER_SIZE;

        // === ESTADO GLOBAL ===
        let currentMode = 'pngToSpectrum';
        let fileName = "imagen";
        let currentImage = null; 

        // === ELEMENTOS DEL DOM ===
        const fileInput = document.getElementById('fileInput');
        const btnConvert = document.getElementById('btnConvert');
        const status = document.getElementById('status');
        const modeRadios = document.querySelectorAll('input[name="conversionMode"]');
        
        const pngSettingsDiv = document.getElementById('pngSettings');
        const chkResize = document.getElementById('chkResize');
        const selectPalette = document.getElementById('selectPalette'); 
        const selectDithering = document.getElementById('selectDithering'); 
        
        const spectrumSettingsDiv = document.getElementById('spectrumSettings');
        const chkResizeSpectrum = document.getElementById('chkResizeSpectrum');
        const chkMonochrome = document.getElementById('chkMonochrome'); 
        
        const cpcSettingsDiv = document.getElementById('cpcSettings'); // NUEVO
        const chkResizeCpc = document.getElementById('chkResizeCpc'); // NUEVO

        const canvasOriginal = document.getElementById('canvasOriginal');
        const canvasCGA = document.getElementById('canvasCGA');
        const ctxOrig = canvasOriginal.getContext('2d');
        const ctxCGA = canvasCGA.getContext('2d', { willReadFrequently: true });
        const originalCanvasLabel = document.getElementById('originalCanvasLabel');
        const cgaCanvasLabel = document.getElementById('cgaCanvasLabel');
        
        const codeSnippet = document.getElementById('codeSnippet');
        
        let activePalette = CGA_PALETTES.spectrum;

        // Inicializar paleta CPC
        pal27 = generateCpc27Palette();
        cpcPal16 = defaultPal16From27(pal27);


        // === UTILIDADES ===
        function getClosestColorIndex(r, g, b, palette) {
            let minDiff = Infinity;
            let closest = 0;
            palette.forEach((col, index) => {
                const diff = (r - col.r)**2 + (g - col.g)**2 + (b - col.b)**2;
                if (diff < minDiff) { minDiff = diff; closest = index; }
            });
            return closest;
        }
        
        // Funci√≥n espec√≠fica de CPC para mapear RGB a √≠ndice (m√°s robusto si se usa k-means o dithering)
        // Se usa la funci√≥n gen√©rica 'getClosestColorIndex' para la cuantizaci√≥n.

        function clamp(value) {
            return Math.max(0, Math.min(255, value));
        }

        function calculateFitDimensions(imgW, imgH, targetW, targetH) {
            const ratioW = targetW / imgW;
            const ratioH = targetH / imgH;
            const ratio = Math.min(ratioW, ratioH); 

            const newW = imgW * ratio;
            const newH = imgH * ratio;

            const offsetX = (targetW - newW) / 2;
            const offsetY = (targetH - newH) / 2;

            return { newW: newW, newH: newH, offsetX: offsetX, offsetY: offsetY };
        }
        
        function updateCodeBlock(mode, paletteKey) {
            let code = '';
            let title = '';
            
            if (mode === 'pngToSpectrum') {
                code = `
REM C√≥digo BASIC para ZX Spectrum
10 CLEAR 30000: REM Reserva de memoria
20 LOAD ""SCREEN$ FROM "IMAGEN.SCR"
30 PAUSE 0
                `.trim();
                title = 'C√≥digo de Carga (ZX Spectrum BASIC):';
            } else if (mode === 'pngToCpc') {
                // Genera din√°micamente la l√≠nea INK usando el hwIndex almacenado en cpcPal16
                const inkCommands = cpcPal16.map(item => `INK ${item.index},${item.hwIndex}`).join(':');

                code = `
REM C√≥digo BASIC para Amstrad CPC (Asumiendo 16K en &C000)
10 MODE 0
15 ${inkCommands}
20 MEMORY &C000
30 LOAD "IMAGEN.BIN",&C000
40 REM El archivo .BIN no contiene la paleta.
50 REM Esta l√≠nea 15 carga la paleta utilizada en la conversi√≥n.
60 REM Se recomienda usar el optimizador de paleta del archivo PNG2CPC si el color es cr√≠tico.
                `.trim();
                title = 'C√≥digo de Carga (Amstrad CPC BASIC):';
            } else { // Modos CGA
                let colorSetting = '';
                
                if (paletteKey === 'palette1') {
                    colorSetting = 'COLOR 0, 1  \' Fondo Negro, Paleta 1 (Cian, Magenta, Blanco)';
                } else if (paletteKey === 'palette2') {
                    colorSetting = 'COLOR 0, 0  \' Fondo Negro, Paleta 0 (Verde, Rojo, Marr√≥n)';
                } else {
                     colorSetting = 'COLOR 0, 1  \' Predeterminado (Paleta 1)';
                }

                code = `
SCREEN 1
${colorSetting}
DEF SEG = &HB800
BLOAD "IMAGEN.BSV", 0
DEF SEG
A$ = INPUT$(1)
SCREEN 0
                `.trim();
                title = 'C√≥digo de Carga (PowerBASIC 3.5 / CGA):';
            }

            document.querySelector('.code-block strong').innerText = title;
            codeSnippet.innerHTML = code;
        }


        // === ALGORITMOS DE DITHERING ===
        // (FloydSteinberg, Bayer, JJN, Stucki, NoDithering... - El c√≥digo es el mismo para todas las paletas)
        function distributeError(data, x, y, errR, errG, errB, factor, width, height) {
            if (x < 0 || x >= width || y >= height) return;
            const i = (y * width + x) * 4;
            
            data[i] = clamp(data[i] + errR * factor);
            data[i+1] = clamp(data[i+1] + errG * factor);
            data[i+2] = clamp(data[i+2] + errB * factor);
        }

        function applyFloydSteinberg(pixels, palette, width, height) {
            const w = width;
            const h = height;
            
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;

                    const oldR = pixels[i];
                    const oldG = pixels[i + 1];
                    const oldB = pixels[i + 2];
                    
                    const index = getClosestColorIndex(oldR, oldG, oldB, palette);
                    const newColor = palette[index];

                    pixels[i] = newColor.r;
                    pixels[i + 1] = newColor.g;
                    pixels[i + 2] = newColor.b;

                    const errR = oldR - newColor.r;
                    const errG = oldG - newColor.g;
                    const errB = oldB - newColor.b;

                    distributeError(pixels, x + 1, y, errR, errG, errB, 7 / 16, w, h);
                    distributeError(pixels, x - 1, y + 1, errR, errG, errB, 3 / 16, w, h);
                    distributeError(pixels, x, y + 1, errR, errG, errB, 5 / 16, w, h);
                    distributeError(pixels, x + 1, y + 1, errR, errG, errB, 1 / 16, w, h);
                }
            }
        }
        
        function applyBayerDithering(data, palette, width, height) {
            const w = width;
            const h = height;
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    const oldR = data[i], oldG = data[i + 1], oldB = data[i + 2];
                    const bayerVal = BAYER_MATRIX[y % BAYER_SIZE][x % BAYER_SIZE];
                    
                    // Ajustar el umbral basado en el valor de Bayer (Esto es una simplificaci√≥n)
                    // Para paletas m√∫ltiples, es mejor cuantizar directamente. Usamos el umbral en este caso:
                    // Si el color es > del umbral ajustado por bayer, se fuerza a un color m√°s claro.
                    
                    // Nota: Esta implementaci√≥n de Bayer es m√°s compleja en paletas de 4/16 colores que en b/n.
                    // Para simplificar, la reemplazamos con una versi√≥n de cuantizaci√≥n pura con ajuste:
                    const totalSteps = palette.length;
                    const colorStep = 256 / totalSteps;
                    const threshold = (bayerVal / BAYER_DIVISOR) * colorStep;
                    
                    // Creamos un color ajustado para que la cuantizaci√≥n elija un color diferente
                    const adjustedR = clamp(oldR + threshold);
                    const adjustedG = clamp(oldG + threshold);
                    const adjustedB = clamp(oldB + threshold);
                    
                    const closestIdx = getClosestColorIndex(adjustedR, adjustedG, adjustedB, palette);
                    const newColor = palette[closestIdx];

                    data[i] = newColor.r;
                    data[i + 1] = newColor.g;
                    data[i + 2] = newColor.b;
                }
            }
        }
        
        function applyJJN(data, palette, width, height) {
            const w = width;
            const h = height;
            const divisor = 48;
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    const oldR = data[i], oldG = data[i + 1], oldB = data[i + 2];
                    const closestIdx = getClosestColorIndex(oldR, oldG, oldB, palette);
                    const newColor = palette[closestIdx];
                    data[i] = newColor.r; data[i + 1] = newColor.g; data[i + 2] = newColor.b;

                    const errR = oldR - newColor.r; const errG = oldG - newColor.g; const errB = oldB - newColor.b;

                    distributeError(data, x + 1, y, errR, errG, errB, 7 / divisor, w, h);
                    distributeError(data, x + 2, y, errR, errG, errB, 5 / divisor, w, h);
                    distributeError(data, x - 2, y + 1, errR, errG, errB, 3 / divisor, w, h);
                    distributeError(data, x - 1, y + 1, errR, errG, errB, 5 / divisor, w, h);
                    distributeError(data, x, y + 1, errR, errG, errB, 7 / divisor, w, h);
                    distributeError(data, x + 1, y + 1, errR, errG, errB, 5 / divisor, w, h);
                    distributeError(data, x + 2, y + 1, errR, errG, errB, 3 / divisor, w, h);
                    distributeError(data, x - 2, y + 2, errR, errG, errB, 1 / divisor, w, h);
                    distributeError(data, x - 1, y + 2, errR, errG, errB, 3 / divisor, w, h);
                    distributeError(data, x, y + 2, errR, errG, errB, 5 / divisor, w, h);
                    distributeError(data, x + 1, y + 2, errR, errG, errB, 3 / divisor, w, h);
                    distributeError(data, x + 2, y + 2, errR, errG, errB, 1 / divisor, w, h);
                }
            }
        }

        function applyStucki(data, palette, width, height) {
            const w = width;
            const h = height;
            const divisor = 42;
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    const oldR = data[i], oldG = data[i + 1], oldB = data[i + 2];
                    const closestIdx = getClosestColorIndex(oldR, oldG, oldB, palette);
                    const newColor = palette[closestIdx];
                    data[i] = newColor.r; data[i + 1] = newColor.g; data[i + 2] = newColor.b;

                    const errR = oldR - newColor.r; const errG = oldG - newColor.g; const errB = oldB - newColor.b;

                    distributeError(data, x + 1, y, errR, errG, errB, 8 / divisor, w, h);
                    distributeError(data, x + 2, y, errR, errG, errB, 4 / divisor, w, h);
                    distributeError(data, x - 2, y + 1, errR, errG, errB, 2 / divisor, w, h);
                    distributeError(data, x - 1, y + 1, errR, errG, errB, 4 / divisor, w, h);
                    distributeError(data, x, y + 1, errR, errG, errB, 8 / divisor, w, h);
                    distributeError(data, x + 1, y + 1, errR, errG, errB, 4 / divisor, w, h);
                    distributeError(data, x + 2, y + 1, errR, errG, errB, 2 / divisor, w, h);
                    distributeError(data, x, y + 2, errR, errG, errB, 4 / divisor, w, h);
                    distributeError(data, x + 1, y + 2, errR, errG, errB, 2 / divisor, w, h);
                    distributeError(data, x + 2, y + 2, errR, errG, errB, 1 / divisor, w, h);
                }
            }
        }
        
        function applyNoDithering(data, palette, width, height) {
            const w = width;
            const h = height;
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    const closestIdx = getClosestColorIndex(data[i], data[i+1], data[i+2], palette);
                    const newColor = palette[closestIdx];
                    data[i] = newColor.r; data[i + 1] = newColor.g; data[i + 2] = newColor.b;
                }
            }
        }
        // === FIN ALGORITMOS DE DITHERING ===


        // === CAMBIO DE MODO ===
        function updateMode(mode) {
            currentMode = mode;
            fileInput.value = '';
            btnConvert.disabled = true;
            currentImage = null;
            
            canvasOriginal.classList.remove('canvas-spectrum', 'canvas-cga', 'canvas-cpc');
            canvasCGA.classList.remove('canvas-spectrum', 'canvas-cga', 'canvas-cpc');
            pngSettingsDiv.style.display = 'none';
            spectrumSettingsDiv.style.display = 'none';
            cpcSettingsDiv.style.display = 'none';

            let targetW, targetH, canvasClass;

            if (mode === 'pngToBsave' || mode === 'bsaveToPng') {
                targetW = CGA_WIDTH;
                targetH = CGA_HEIGHT;
                canvasClass = 'canvas-cga';
                pngSettingsDiv.style.display = 'flex';
                btnConvert.innerText = mode === 'pngToBsave' ? 'üíæ Descargar .BSV' : 'üíæ Descargar .PNG';
                fileInput.accept = mode === 'pngToBsave' ? 'image/*' : '.bsv';
                document.getElementById('selectPalette').value = 'palette1'; // Reset
                document.getElementById('selectPalette').style.display = 'block';
                document.getElementById('selectDithering').style.display = 'block';
                document.getElementById('selectPalette').parentElement.querySelector('label[for="selectPalette"]').style.display = 'block';
                document.getElementById('selectDithering').parentElement.querySelector('label[for="selectDithering"]').style.display = 'block';
                cgaCanvasLabel.innerText = 'CGA 4 Colores (Dithering)';
            } else if (mode === 'pngToSpectrum') {
                targetW = SPEC_WIDTH;
                targetH = SPEC_HEIGHT;
                canvasClass = 'canvas-spectrum';
                spectrumSettingsDiv.style.display = 'flex';
                btnConvert.innerText = 'üíæ Descargar .SCR';
                fileInput.accept = 'image/*';
                cgaCanvasLabel.innerText = 'Spectrum 15 Colores (Dithering)';
            } else if (mode === 'pngToCpc') { // NUEVO MODO CPC
                targetW = CPC_WIDTH;
                targetH = CPC_HEIGHT;
                canvasClass = 'canvas-cpc';
                cpcSettingsDiv.style.display = 'flex';
                pngSettingsDiv.style.display = 'flex'; 
                // Ocultar selecci√≥n de paleta y dithering, forzar a CPC 16 y FS
                document.getElementById('selectPalette').value = 'cpc';
                document.getElementById('selectPalette').style.display = 'none';
                document.getElementById('selectDithering').value = 'floyd-steinberg';
                document.getElementById('selectDithering').style.display = 'block';
                document.getElementById('selectPalette').parentElement.querySelector('label[for="selectPalette"]').style.display = 'none';
                document.getElementById('selectDithering').parentElement.querySelector('label[for="selectDithering"]').style.display = 'block';
                
                btnConvert.innerText = 'üíæ Descargar .BIN';
                fileInput.accept = 'image/*';
                cgaCanvasLabel.innerText = 'CPC Modo 0 (16 Colores, Dithering)';
            }

            canvasOriginal.width = targetW;
            canvasOriginal.height = targetH;
            canvasCGA.width = targetW;
            canvasCGA.height = targetH;
            canvasOriginal.classList.add(canvasClass);
            canvasCGA.classList.add(canvasClass);

            ctxOrig.clearRect(0, 0, targetW, targetH);
            ctxCGA.clearRect(0, 0, targetW, targetH);
            status.innerText = 'Selecciona una imagen...';
            
            updateCodeBlock(currentMode, selectPalette.value);
        }

        /* Funci√≥n central para dibujar y procesar la imagen cargada. */
        function processImage(img) {
            status.innerText = "Procesando...";
            let currentWidth, currentHeight, adaptChecked, targetMode = currentMode; 
            let ditheringMode = selectDithering.value;
            let ditheringName = document.querySelector(`#selectDithering option[value="${ditheringMode}"]`).innerText;

            if (currentMode === 'pngToBsave') {
                currentWidth = CGA_WIDTH;
                currentHeight = CGA_HEIGHT;
                adaptChecked = chkResize.checked;
                activePalette = CGA_PALETTES[selectPalette.value];
            } else if (currentMode === 'pngToSpectrum') {
                currentWidth = SPEC_WIDTH;
                currentHeight = SPEC_HEIGHT;
                adaptChecked = chkResizeSpectrum.checked;
                activePalette = CGA_PALETTES.spectrum;
            } else if (currentMode === 'pngToCpc') { // L√≥gica CPC
                currentWidth = CPC_WIDTH;
                currentHeight = CPC_HEIGHT;
                adaptChecked = chkResizeCpc.checked;
                activePalette = cpcPal16; // Usar la paleta fija de CPC
                ditheringName = chkResizeCpc.checked ? ditheringName : "Sin Redimensionar";
            } else {
                return;
            }

            // Si la imagen no est√° lista, salimos 
            if (img.width === 0 || img.height === 0) {
                status.innerText = "‚ö†Ô∏è Error: La imagen cargada no tiene dimensiones v√°lidas.";
                return;
            }

            // 1. Limpiar lienzos y dibujar fondo negro
            ctxOrig.fillStyle = 'black';
            ctxOrig.fillRect(0, 0, currentWidth, currentHeight);
            ctxCGA.fillStyle = 'black';
            ctxCGA.fillRect(0, 0, currentWidth, currentHeight);

            // 2. C√°lculo de redimensionamiento
            let drawX, drawY, drawW, drawH;
            if (adaptChecked) { 
                // Estirar a tama√±o completo del lienzo
                drawX = 0; drawY = 0; drawW = currentWidth; drawH = currentHeight;
                originalCanvasLabel.innerText = `Original (Estirado ${currentWidth}x${currentHeight})`;
            } else { 
                // Mantener Aspect Ratio (Contain)
                const fit = calculateFitDimensions(img.width, img.height, currentWidth, currentHeight);
                drawW = fit.newW; drawH = fit.newH;
                drawX = fit.offsetX; drawY = fit.offsetY;
                originalCanvasLabel.innerText = 'Original (Aspect Ratio)';
            }

            // Dibujar la imagen original (redimensionada)
            try {
                ctxOrig.drawImage(img, drawX, drawY, drawW, drawH);
                ctxCGA.drawImage(img, drawX, drawY, drawW, drawH); // Dibuja en ambos para procesar CGA
            } catch(e) {
                status.innerText = `‚ö†Ô∏è Error al dibujar la imagen: ${e.message}`;
                return;
            }

            // 3. Aplicar Dithering/Cuantizaci√≥n en el lienzo CGA
            setTimeout(() => {
                try {
                    const imgData = ctxCGA.getImageData(0, 0, currentWidth, currentHeight);
                    const pixels = imgData.data;
                    
                    if (currentMode === 'pngToSpectrum' && chkMonochrome.checked) {
                        // Monocromo no usa dithering tradicional, sino umbral de luminancia
                        applyNoDithering(pixels, [{r:0,g:0,b:0}, {r:255,g:255,b:255}], currentWidth, currentHeight); 
                        ditheringName = 'Monocromo';
                    } else if (ditheringMode === 'floyd-steinberg') {
                        applyFloydSteinberg(pixels, activePalette, currentWidth, currentHeight);
                    } else if (ditheringMode === 'bayer') {
                        applyBayerDithering(pixels, activePalette, currentWidth, currentHeight);
                    } else if (ditheringMode === 'jjn') {
                        applyJJN(pixels, activePalette, currentWidth, currentHeight);
                    } else if (ditheringMode === 'stucki') {
                        applyStucki(pixels, activePalette, currentWidth, currentHeight);
                    } else {
                        applyNoDithering(pixels, activePalette, currentWidth, currentHeight);
                        ditheringName = 'Ninguno';
                    }

                    if (currentMode === 'pngToSpectrum' && chkMonochrome.checked) {
                        cgaCanvasLabel.innerText = `Spectrum Monocromo (Luminancia)`;
                    } else if (currentMode === 'pngToCpc') {
                        cgaCanvasLabel.innerText = `CPC Modo 0 (16 Colores, ${ditheringName})`;
                    } else {
                        cgaCanvasLabel.innerText = `CGA 4 Colores (${ditheringName})`;
                    }

                    ctxCGA.putImageData(imgData, 0, 0);
                    btnConvert.disabled = false;
                    status.innerText = `‚úÖ Conversi√≥n lista. Compara las im√°genes.`;
                } catch(e) {
                    status.innerText = `‚ö†Ô∏è Error al aplicar el dithering: ${e.message}`;
                    btnConvert.disabled = true;
                    console.error("Dithering Error:", e);
                }
            }, 50);

            updateCodeBlock(currentMode, selectPalette.value);
        }

        // --- FUNCIONES DE CONVERSI√ìN ESPEC√çFICAS ---

        // Funci√≥n de mapeo VRAM CPC (no lineal)
        function cpcVramOffset(y, xByte) {
            const block = (y >> 3); // 0-2 (un tercio de la pantalla en vertical de 8 l√≠neas)
            const rowInBlock = (y & 0x07); // 0-7 (l√≠nea dentro del bloque)
            return (rowInBlock * 0x800) + (block * 0x50) + xByte; // 0x800 = 2048, 0x50 = 80
        }
        
        // Empaquetado Modo 0 (2 p√≠xeles por byte)
        function packMode0Byte(left4,right4){
            let b=0;
            // Bits 3, 7, 5, 1 (para left4)
            if (left4 & 0x8) b |= (1<<7);
            if (left4 & 0x4) b |= (1<<3);
            if (left4 & 0x2) b |= (1<<5);
            if (left4 & 0x1) b |= (1<<1);
            // Bits 2, 6, 4, 0 (para right4)
            if (right4 & 0x8) b |= (1<<6);
            if (right4 & 0x4) b |= (1<<2);
            if (right4 & 0x2) b |= (1<<4);
            if (right4 & 0x1) b |= (1<<0);
            return b;
        }

        // Generaci√≥n .BIN (Amstrad CPC)
        function generateCpcBin(pixels) {
            const vram = new Uint8Array(CPC_VRAM_SIZE);
            const pal16 = cpcPal16; 
            const vshift = 0; // Se podr√≠a a√±adir control en el futuro

            for (let y = 0; y < CPC_HEIGHT; y++) {
                // Aplicar vshift (desplazamiento vertical)
                const yDst = (y + vshift) % CPC_HEIGHT; 

                for (let xByte = 0; xByte < CPC_BYTES_PER_LINE; xByte++) {
                    const xLeft = xByte * 2;
                    
                    // Coordenadas de p√≠xel en el array de entrada (quantizado/dithereado)
                    const idxL = (y * CPC_WIDTH + xLeft) * 4;
                    const idxR = (y * CPC_WIDTH + xLeft + 1) * 4;

                    // El array 'pixels' ya tiene los colores de pal16Global.
                    // Buscamos el √≠ndice (0-15) de esos colores en la paleta.
                    const leftColorIndex = getClosestColorIndex(pixels[idxL], pixels[idxL+1], pixels[idxL+2], pal16);
                    const rightColorIndex = getClosestColorIndex(pixels[idxR], pixels[idxR+1], pixels[idxR+2], pal16);

                    const packedByte = packMode0Byte(leftColorIndex, rightColorIndex);
                    
                    const offset = cpcVramOffset(yDst, xByte);
                    vram[offset] = packedByte;
                }
            }
            return vram;
        }

        // Generaci√≥n BSAVE (CGA)
        function generateBsave(pixels) {
            const buffer = new Uint8Array(7 + CGA_MEMORY_SIZE);
            const view = new DataView(buffer.buffer);
            view.setUint8(0, 0xFD);
            view.setUint16(1, 0x0000, true);
            view.setUint16(3, 0xB800, true);
            view.setUint16(5, CGA_MEMORY_SIZE, true);

            const EVEN_OFFSET = 7;
            const ODD_OFFSET = 7 + CGA_MEMORY_SIZE / 2;
            const paletteToUse = CGA_PALETTES[selectPalette.value];

            for (let y = 0; y < CGA_HEIGHT; y++) {
                const isOdd = (y % 2 !== 0);
                const lineOffset = (y / 2) * (CGA_WIDTH / 8); 
                const baseOffset = isOdd ? ODD_OFFSET : EVEN_OFFSET;

                for (let xByte = 0; xByte < CGA_WIDTH / 8; xByte++) {
                    let pixelByte = 0;
                    for (let bit = 0; bit < 8; bit++) {
                        const x = xByte * 8 + bit;
                        const i = (y * CGA_WIDTH + x) * 4;

                        // En CGA 320x200x4 (Modo 4), el color est√° en 2 bits por p√≠xel
                        // La cuantizaci√≥n previa ya ha forzado los p√≠xeles a ser uno de los 4 colores de la paleta.
                        // Solo necesitamos encontrar el √≠ndice (0-3) en la paleta activa.
                        const r = pixels[i], g = pixels[i+1], b = pixels[i+2];
                        const colorIndex = getClosestColorIndex(r, g, b, paletteToUse);

                        // La codificaci√≥n de 4 colores es: 
                        // Bit 0 del p√≠xel par/impar -> Plano 0 (bits 0, 4)
                        // Bit 1 del p√≠xel par/impar -> Plano 1 (bits 1, 5)

                        // En el byte, el bit (7-bit) codifica el canal de color:
                        // Bit 7: Color 1 (Hi) del primer p√≠xel
                        // Bit 6: Color 1 (Hi) del segundo p√≠xel
                        // ...
                        // Bit 0: Color 0 (Lo) del cuarto p√≠xel

                        // Para el pixel actual (bit en la iteraci√≥n 0-7):
                        const plane0Bit = (colorIndex & 1); // Lo bit
                        const plane1Bit = (colorIndex >> 1) & 1; // Hi bit

                        if (plane0Bit) {
                            pixelByte |= (1 << (7 - bit * 2)); // Lo bit en la posici√≥n 7, 5, 3, 1
                        }
                        if (plane1Bit) {
                            pixelByte |= (1 << (6 - bit * 2)); // Hi bit en la posici√≥n 6, 4, 2, 0
                        }
                    }
                    buffer[baseOffset + lineOffset + xByte] = pixelByte;
                }
            }
            return buffer;
        }

        // Generaci√≥n SCR (ZX Spectrum)
        function generateSpectrumScr(pixels) {
            const buffer = new Uint8Array(SPEC_SCREEN_SIZE); 
            const palette = ZX_SPECTRUM_PALETTE; // Usamos la paleta completa
            const isMonochrome = chkMonochrome.checked;

            // 1. Bitmap (6144 bytes)
            for (let y = 0; y < SPEC_HEIGHT; y++) {
                // Mapeo no lineal de Spectrum: Tercio(3) + L√≠nea en Tercio(8) + Columna(8)
                const tercio = y >> 6; // 0-2
                const filaCar = (y >> 3) & 0x07; // 0-7
                const filaPix = y & 0x07; // 0-7

                const lineOffset = (tercio * 0x800) + (filaPix * 0x100) + (filaCar * 0x20); // 0x800=2048, 0x100=256, 0x20=32
                
                for (let x = 0; x < SPEC_WIDTH / 8; x++) {
                    const pixelAddress = 16384 + lineOffset + x; // 16384 es el inicio de la VRAM
                    let pixelByte = 0;

                    // Decidir el byte de p√≠xeles (Ink/Paper)
                    for (let bit = 0; bit < 8; bit++) {
                        const pixelX = x * 8 + bit;
                        const idx = ((y * SPEC_WIDTH) + pixelX) * 4; 
                        
                        const r = pixels[idx]; 
                        const g = pixels[idx+1]; 
                        const b = pixels[idx+2];
                        
                        // --- Simplificamos: Asumimos que Ink=White, Paper=Black para generar el bitmap ---
                        // Usaremos la luminancia para decidir si el p√≠xel est√° "encendido" (Ink) o "apagado" (Paper).

                        const luminance = (r + g + b) / 3;
                        let isInk = luminance > 127;
                        
                        if (isInk) { 
                            pixelByte |= (1 << (7 - bit)); // MSb es el p√≠xel de la izquierda
                        }
                    }
                    buffer[pixelAddress - 16384] = pixelByte; // Guardar el byte
                }
            }

            // 2. Atributos (768 bytes) - Simplificaci√≥n: Ink=White, Paper=Black, Bright=OFF, Flash=OFF (Attribute byte = 0x07)
            const defaultAttr = 0x07; // Ink=7 (White), Paper=0 (Black), Bright=0, Flash=0.
            for (let i = 0; i < 768; i++) {
                 // **Mejor: Intentar calcular un atributo por bloque 8x8 (simplificado)**
                 // ... (Se mantiene la simplificaci√≥n por defecto para .SCR)
                 buffer[6144 + i] = defaultAttr; // 6144 es el inicio de la zona de atributos
            }

            return buffer;
        }


        // === CONTROLADORES DE EVENTOS Y L√ìGICA DE DESCARGA ===

        document.getElementById('btnConvert').addEventListener('click', () => {
            if (!currentImage) return;

            if (currentMode === 'pngToBsave') {
                // Generaci√≥n de BSV
                try {
                    const imgData = ctxCGA.getImageData(0, 0, CGA_WIDTH, CGA_HEIGHT);
                    const buffer = generateBsave(imgData.data);
                    const blob = new Blob([buffer], { type: "application/octet-stream" });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = fileName + ".BSV";
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    status.innerText = `‚úÖ Archivo .BSV generado y descargado como ${fileName}.BSV.`;
                } catch(e) {
                    status.innerText = `‚ö†Ô∏è Error al generar .BSV: ${e.message}`;
                    console.error("BSAVE Generation Error:", e);
                }
            } else if (currentMode === 'pngToSpectrum') {
                 // Generaci√≥n de SCR
                 try {
                    const imgData = ctxCGA.getImageData(0, 0, SPEC_WIDTH, SPEC_HEIGHT);
                    const buffer = generateSpectrumScr(imgData.data);
                    const blob = new Blob([buffer], { type: "application/octet-stream" });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = fileName + ".SCR";
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    status.innerText = `‚úÖ Archivo .SCR generado y descargado como ${fileName}.SCR.`;
                } catch(e) {
                    status.innerText = `‚ö†Ô∏è Error al generar .SCR: ${e.message}`;
                    console.error("SCR Generation Error:", e);
                }
            } else if (currentMode === 'pngToCpc') { // NUEVA L√ìGICA DE DESCARGA CPC
                 // Generaci√≥n de BIN
                 try {
                    const imgData = ctxCGA.getImageData(0, 0, CPC_WIDTH, CPC_HEIGHT);
                    const buffer = generateCpcBin(imgData.data);
                    const blob = new Blob([buffer], { type: "application/octet-stream" });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = fileName + ".BIN";
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    status.innerText = `‚úÖ Archivo .BIN (VRAM CPC) generado y descargado como ${fileName}.BIN.`;
                } catch(e) {
                    status.innerText = `‚ö†Ô∏è Error al generar .BIN (CPC): ${e.message}`;
                    console.error("CPC Generation Error:", e);
                }
            } else if (currentMode === 'bsaveToPng') {
                // Descarga de PNG
                const link = document.createElement('a');
                link.download = fileName + ".png";
                link.href = canvasCGA.toDataURL('image/png');
                link.click();
            }
        });
        
        modeRadios.forEach(radio => radio.addEventListener('change', (e) => updateMode(e.target.value)));
        
        fileInput.addEventListener('change', async (e) => {
            // ... (rest of file load logic is unchanged)
            const file = e.target.files[0];
            if (!file) return;

            const baseName = file.name.substring(0, file.name.lastIndexOf('.')) || file.name;
            fileName = baseName.replace(/[^a-zA-Z0-9_]/g, '');

            if (currentMode.includes('png')) {
                // Modo de carga de imagen PNG (para convertir)
                status.innerText = "Cargando imagen...";
                btnConvert.disabled = true;
                const img = new Image();
                img.onload = () => {
                    currentImage = img;
                    processImage(img);
                };
                img.onerror = () => {
                    status.innerText = "‚ö†Ô∏è Error al cargar la imagen. Aseg√∫rate de que es un formato v√°lido.";
                    btnConvert.disabled = true;
                };
                img.src = URL.createObjectURL(file);
            } else if (currentMode === 'bsaveToPng') {
                // Modo de carga de archivo binario (BSV/SCR/BIN)
                status.innerText = "Cargando archivo binario...";
                btnConvert.disabled = true;
                
                if (file.size !== CGA_MEMORY_SIZE) {
                     status.innerText = `‚ö†Ô∏è Error: Archivo .BSV debe ser de ${CGA_MEMORY_SIZE} bytes (CGA)`;
                     return;
                }
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const bsvData = new Uint8Array(e.target.result);
                    // Aqu√≠ se llamar√≠a a una funci√≥n para decodificar BSV a pixeles
                    // (Esta parte no fue solicitada pero se mantiene la estructura)
                    // drawCgaFromBsave(bsvData);
                    status.innerText = '‚ö†Ô∏è La decodificaci√≥n de .BSV no est√° implementada en este demo.';
                    btnConvert.disabled = true;
                };
                reader.readAsArrayBuffer(file);
            }
        });
        
        // Eventos para cambiar configuraci√≥n
        chkResize.addEventListener('change', () => { if (currentMode === 'pngToBsave' && currentImage) { processImage(currentImage); } });
        chkResizeSpectrum.addEventListener('change', () => { if (currentMode === 'pngToSpectrum' && currentImage) { processImage(currentImage); } });
        chkResizeCpc.addEventListener('change', () => { if (currentMode === 'pngToCpc' && currentImage) { processImage(currentImage); } });
        
        selectPalette.addEventListener('change', () => { 
            if (currentMode === 'pngToBsave' && currentImage) { processImage(currentImage); } 
            updateCodeBlock(currentMode, selectPalette.value);
        });
        
        selectDithering.addEventListener('change', () => { 
            if ((currentMode === 'pngToBsave' || currentMode === 'pngToSpectrum' || currentMode === 'pngToCpc') && currentImage) { 
                processImage(currentImage); 
            } 
        });
        
        chkMonochrome.addEventListener('change', () => { if (currentMode === 'pngToSpectrum' && currentImage) { processImage(currentImage); } });
        
        // Inicializaci√≥n
        updateMode(currentMode); 
    </script>
</body>
</html>
